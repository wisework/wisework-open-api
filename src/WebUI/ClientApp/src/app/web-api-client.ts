//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.0.0 (NJsonSchema v10.7.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAuthenticationClient {
    login(command: LoginCommand): Observable<AuthenticationInfo>;
    logout(command: LogoutCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthenticationClient implements IAuthenticationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    login(command: LoginCommand): Observable<AuthenticationInfo> {
        let url_ = this.baseUrl + "/api/Authentication/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationInfo>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticationInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    logout(command: LogoutCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Authentication/logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICompanyClient {
    get(): Observable<Company[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CompanyClient implements ICompanyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<Company[]> {
        let url_ = this.baseUrl + "/api/Company";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Company[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Company[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Company[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Company.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IConsentPageSettingClient {
    getConsentThemeQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfConsentTheme>;
    create(command: CreateConsentThemeCommand): Observable<ConsentTheme>;
    update(id: number, command: UpdateConsentThemeCommand): Observable<ConsentTheme>;
    getShortUrlQuery(id: number): Observable<ShortUrl>;
    getLogoQuery(count: number): Observable<Image[]>;
    getImageQuery(count: number): Observable<Image[]>;
}

@Injectable({
    providedIn: 'root'
})
export class ConsentPageSettingClient implements IConsentPageSettingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getConsentThemeQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfConsentTheme> {
        let url_ = this.baseUrl + "/api/ConsentPageSetting/themes?";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsentThemeQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsentThemeQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfConsentTheme>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfConsentTheme>;
        }));
    }

    protected processGetConsentThemeQuery(response: HttpResponseBase): Observable<PaginatedListOfConsentTheme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfConsentTheme.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateConsentThemeCommand): Observable<ConsentTheme> {
        let url_ = this.baseUrl + "/api/ConsentPageSetting/theme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsentTheme>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsentTheme>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ConsentTheme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsentTheme.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateConsentThemeCommand): Observable<ConsentTheme> {
        let url_ = this.baseUrl + "/api/ConsentPageSetting/update-theme/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConsentTheme>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConsentTheme>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ConsentTheme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConsentTheme.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getShortUrlQuery(id: number): Observable<ShortUrl> {
        let url_ = this.baseUrl + "/api/ConsentPageSetting/short-url/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShortUrlQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShortUrlQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShortUrl>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShortUrl>;
        }));
    }

    protected processGetShortUrlQuery(response: HttpResponseBase): Observable<ShortUrl> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShortUrl.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLogoQuery(count: number): Observable<Image[]> {
        let url_ = this.baseUrl + "/api/ConsentPageSetting/logo/{count}";
        if (count === undefined || count === null)
            throw new Error("The parameter 'count' must be defined.");
        url_ = url_.replace("{count}", encodeURIComponent("" + count));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogoQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogoQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Image[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Image[]>;
        }));
    }

    protected processGetLogoQuery(response: HttpResponseBase): Observable<Image[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Image.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getImageQuery(count: number): Observable<Image[]> {
        let url_ = this.baseUrl + "/api/ConsentPageSetting/image/{count}";
        if (count === undefined || count === null)
            throw new Error("The parameter 'count' must be defined.");
        url_ = url_.replace("{count}", encodeURIComponent("" + count));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Image[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Image[]>;
        }));
    }

    protected processGetImageQuery(response: HttpResponseBase): Observable<Image[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Image.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICustomFieldClient {
    getCollectionPointsQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfCollectionPointCustomFieldActiveList>;
    create(command: CreateCustomFieldCommand): Observable<CollectionPointCustomFieldActiveList>;
    update(id: number, command: UpdateCustomFieldCommand): Observable<CollectionPointCustomFieldActiveList>;
    get(id: number): Observable<CollectionPointCustomFieldActiveList>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomFieldClient implements ICustomFieldClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCollectionPointsQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfCollectionPointCustomFieldActiveList> {
        let url_ = this.baseUrl + "/api/CustomField?";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollectionPointsQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollectionPointsQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCollectionPointCustomFieldActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCollectionPointCustomFieldActiveList>;
        }));
    }

    protected processGetCollectionPointsQuery(response: HttpResponseBase): Observable<PaginatedListOfCollectionPointCustomFieldActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCollectionPointCustomFieldActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCustomFieldCommand): Observable<CollectionPointCustomFieldActiveList> {
        let url_ = this.baseUrl + "/api/CustomField";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CollectionPointCustomFieldActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CollectionPointCustomFieldActiveList>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CollectionPointCustomFieldActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CollectionPointCustomFieldActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCustomFieldCommand): Observable<CollectionPointCustomFieldActiveList> {
        let url_ = this.baseUrl + "/api/CustomField/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CollectionPointCustomFieldActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CollectionPointCustomFieldActiveList>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CollectionPointCustomFieldActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CollectionPointCustomFieldActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: number): Observable<CollectionPointCustomFieldActiveList> {
        let url_ = this.baseUrl + "/api/CustomField/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CollectionPointCustomFieldActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CollectionPointCustomFieldActiveList>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CollectionPointCustomFieldActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CollectionPointCustomFieldActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IGeneralConsentClient {
    getGeneralConsentQuery(paginationParams_Offset: number | null | undefined, paginationParams_Limit: number | null | undefined, sortingParams_SortName: string | null | undefined, sortingParams_SortDesc: number | null | undefined, generalConsentFilterKey_FullName: string | null | undefined, generalConsentFilterKey_PhoneNumber: string | null | undefined, generalConsentFilterKey_IdCardNumber: string | null | undefined, generalConsentFilterKey_Uid: number | null | undefined, generalConsentFilterKey_Email: string | null | undefined, generalConsentFilterKey_StartDate: Date | null | undefined, generalConsentFilterKey_EndDate: Date | null | undefined, currentUtcOffset: string | null | undefined, isCurrentlyDst: string | null | undefined): Observable<PaginatedListOfGeneralConsent>;
    create(command: SubmitConsentCommand): Observable<number>;
    getLatestId(query: GetLatestIdRequestQuery): Observable<number>;
    getGeneralConsentInfoQuery(query: GeneralConsentInfoRequestQuery): Observable<GeneralConsent>;
}

@Injectable({
    providedIn: 'root'
})
export class GeneralConsentClient implements IGeneralConsentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getGeneralConsentQuery(paginationParams_Offset: number | null | undefined, paginationParams_Limit: number | null | undefined, sortingParams_SortName: string | null | undefined, sortingParams_SortDesc: number | null | undefined, generalConsentFilterKey_FullName: string | null | undefined, generalConsentFilterKey_PhoneNumber: string | null | undefined, generalConsentFilterKey_IdCardNumber: string | null | undefined, generalConsentFilterKey_Uid: number | null | undefined, generalConsentFilterKey_Email: string | null | undefined, generalConsentFilterKey_StartDate: Date | null | undefined, generalConsentFilterKey_EndDate: Date | null | undefined, currentUtcOffset: string | null | undefined, isCurrentlyDst: string | null | undefined): Observable<PaginatedListOfGeneralConsent> {
        let url_ = this.baseUrl + "/api/GeneralConsent?";
        if (paginationParams_Offset !== undefined && paginationParams_Offset !== null)
            url_ += "PaginationParams.Offset=" + encodeURIComponent("" + paginationParams_Offset) + "&";
        if (paginationParams_Limit !== undefined && paginationParams_Limit !== null)
            url_ += "PaginationParams.Limit=" + encodeURIComponent("" + paginationParams_Limit) + "&";
        if (sortingParams_SortName !== undefined && sortingParams_SortName !== null)
            url_ += "SortingParams.SortName=" + encodeURIComponent("" + sortingParams_SortName) + "&";
        if (sortingParams_SortDesc !== undefined && sortingParams_SortDesc !== null)
            url_ += "SortingParams.SortDesc=" + encodeURIComponent("" + sortingParams_SortDesc) + "&";
        if (generalConsentFilterKey_FullName !== undefined && generalConsentFilterKey_FullName !== null)
            url_ += "GeneralConsentFilterKey.FullName=" + encodeURIComponent("" + generalConsentFilterKey_FullName) + "&";
        if (generalConsentFilterKey_PhoneNumber !== undefined && generalConsentFilterKey_PhoneNumber !== null)
            url_ += "GeneralConsentFilterKey.PhoneNumber=" + encodeURIComponent("" + generalConsentFilterKey_PhoneNumber) + "&";
        if (generalConsentFilterKey_IdCardNumber !== undefined && generalConsentFilterKey_IdCardNumber !== null)
            url_ += "GeneralConsentFilterKey.IdCardNumber=" + encodeURIComponent("" + generalConsentFilterKey_IdCardNumber) + "&";
        if (generalConsentFilterKey_Uid !== undefined && generalConsentFilterKey_Uid !== null)
            url_ += "GeneralConsentFilterKey.Uid=" + encodeURIComponent("" + generalConsentFilterKey_Uid) + "&";
        if (generalConsentFilterKey_Email !== undefined && generalConsentFilterKey_Email !== null)
            url_ += "GeneralConsentFilterKey.Email=" + encodeURIComponent("" + generalConsentFilterKey_Email) + "&";
        if (generalConsentFilterKey_StartDate !== undefined && generalConsentFilterKey_StartDate !== null)
            url_ += "GeneralConsentFilterKey.StartDate=" + encodeURIComponent(generalConsentFilterKey_StartDate ? "" + generalConsentFilterKey_StartDate.toISOString() : "") + "&";
        if (generalConsentFilterKey_EndDate !== undefined && generalConsentFilterKey_EndDate !== null)
            url_ += "GeneralConsentFilterKey.EndDate=" + encodeURIComponent(generalConsentFilterKey_EndDate ? "" + generalConsentFilterKey_EndDate.toISOString() : "") + "&";
        if (currentUtcOffset !== undefined && currentUtcOffset !== null)
            url_ += "CurrentUtcOffset=" + encodeURIComponent("" + currentUtcOffset) + "&";
        if (isCurrentlyDst !== undefined && isCurrentlyDst !== null)
            url_ += "IsCurrentlyDst=" + encodeURIComponent("" + isCurrentlyDst) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralConsentQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralConsentQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfGeneralConsent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfGeneralConsent>;
        }));
    }

    protected processGetGeneralConsentQuery(response: HttpResponseBase): Observable<PaginatedListOfGeneralConsent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfGeneralConsent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: SubmitConsentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/GeneralConsent/submit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLatestId(query: GetLatestIdRequestQuery): Observable<number> {
        let url_ = this.baseUrl + "/api/GeneralConsent/latest-id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLatestId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getGeneralConsentInfoQuery(query: GeneralConsentInfoRequestQuery): Observable<GeneralConsent> {
        let url_ = this.baseUrl + "/api/GeneralConsent/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralConsentInfoQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralConsentInfoQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralConsent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralConsent>;
        }));
    }

    protected processGetGeneralConsentInfoQuery(response: HttpResponseBase): Observable<GeneralConsent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralConsent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILanguageClient {
    get(languageCultureKeys: string | null, resourceKeys: string | null): Observable<{ [key: string]: { [key: string]: string; }; }>;
}

@Injectable({
    providedIn: 'root'
})
export class LanguageClient implements ILanguageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(languageCultureKeys: string | null, resourceKeys: string | null): Observable<{ [key: string]: { [key: string]: string; }; }> {
        let url_ = this.baseUrl + "/api/Language/{languageCultureKeys}/{resourceKeys}";
        if (languageCultureKeys === undefined || languageCultureKeys === null)
            throw new Error("The parameter 'languageCultureKeys' must be defined.");
        url_ = url_.replace("{languageCultureKeys}", encodeURIComponent("" + languageCultureKeys));
        if (resourceKeys === undefined || resourceKeys === null)
            throw new Error("The parameter 'resourceKeys' must be defined.");
        url_ = url_.replace("{resourceKeys}", encodeURIComponent("" + resourceKeys));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: { [key: string]: string; }; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: { [key: string]: string; }; }>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<{ [key: string]: { [key: string]: string; }; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : {};
                }
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPurposeCategoryClient {
    getPurposeCategoryQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfPurposeCategoryActiveList>;
    create(command: CreatePurposeCategoryCommand): Observable<PurposeCategoryActiveList>;
    update(id: number, command: UpdatePurposeCategoryCommand): Observable<PurposeCategoryActiveList>;
    get(id: number): Observable<PurposeCategoryActiveList>;
}

@Injectable({
    providedIn: 'root'
})
export class PurposeCategoryClient implements IPurposeCategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPurposeCategoryQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfPurposeCategoryActiveList> {
        let url_ = this.baseUrl + "/api/PurposeCategory?";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurposeCategoryQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurposeCategoryQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfPurposeCategoryActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfPurposeCategoryActiveList>;
        }));
    }

    protected processGetPurposeCategoryQuery(response: HttpResponseBase): Observable<PaginatedListOfPurposeCategoryActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfPurposeCategoryActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreatePurposeCategoryCommand): Observable<PurposeCategoryActiveList> {
        let url_ = this.baseUrl + "/api/PurposeCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurposeCategoryActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurposeCategoryActiveList>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PurposeCategoryActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurposeCategoryActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdatePurposeCategoryCommand): Observable<PurposeCategoryActiveList> {
        let url_ = this.baseUrl + "/api/PurposeCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurposeCategoryActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurposeCategoryActiveList>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PurposeCategoryActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurposeCategoryActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: number): Observable<PurposeCategoryActiveList> {
        let url_ = this.baseUrl + "/api/PurposeCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurposeCategoryActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurposeCategoryActiveList>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PurposeCategoryActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurposeCategoryActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPurposeClient {
    getCollectionPointsQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfPurposeActiveList>;
    create(command: CreatePurposeCommand): Observable<PurposeActiveList>;
    update(id: number, command: UpdatePurposeCommand): Observable<PurposeActiveList>;
    get(id: number): Observable<PurposeActiveList>;
}

@Injectable({
    providedIn: 'root'
})
export class PurposeClient implements IPurposeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCollectionPointsQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfPurposeActiveList> {
        let url_ = this.baseUrl + "/api/Purpose?";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollectionPointsQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollectionPointsQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfPurposeActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfPurposeActiveList>;
        }));
    }

    protected processGetCollectionPointsQuery(response: HttpResponseBase): Observable<PaginatedListOfPurposeActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfPurposeActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreatePurposeCommand): Observable<PurposeActiveList> {
        let url_ = this.baseUrl + "/api/Purpose";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurposeActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurposeActiveList>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PurposeActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurposeActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdatePurposeCommand): Observable<PurposeActiveList> {
        let url_ = this.baseUrl + "/api/Purpose/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurposeActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurposeActiveList>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PurposeActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurposeActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: number): Observable<PurposeActiveList> {
        let url_ = this.baseUrl + "/api/Purpose/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurposeActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurposeActiveList>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PurposeActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurposeActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISectionClient {
    getCollectionPointsQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfSectionActiveList>;
    create(command: CreateSectionCommand): Observable<SectionActiveList>;
    update(id: number, command: UpdateSectionCommand): Observable<SectionActiveList>;
    get(id: number): Observable<SectionActiveList>;
}

@Injectable({
    providedIn: 'root'
})
export class SectionClient implements ISectionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCollectionPointsQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfSectionActiveList> {
        let url_ = this.baseUrl + "/api/Section?";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollectionPointsQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollectionPointsQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfSectionActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfSectionActiveList>;
        }));
    }

    protected processGetCollectionPointsQuery(response: HttpResponseBase): Observable<PaginatedListOfSectionActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfSectionActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateSectionCommand): Observable<SectionActiveList> {
        let url_ = this.baseUrl + "/api/Section";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SectionActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SectionActiveList>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SectionActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectionActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateSectionCommand): Observable<SectionActiveList> {
        let url_ = this.baseUrl + "/api/Section/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SectionActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SectionActiveList>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SectionActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectionActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: number): Observable<SectionActiveList> {
        let url_ = this.baseUrl + "/api/Section/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SectionActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SectionActiveList>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SectionActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectionActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserClient {
    get(id: number): Observable<UserInfo>;
}

@Injectable({
    providedIn: 'root'
})
export class UserClient implements IUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: number): Observable<UserInfo> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfo>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWebsiteClient {
    getCollectionPointsQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfWebsiteActiveList>;
    create(command: CreateWebsiteCommands): Observable<WebsiteActiveList>;
    update(id: number, command: UpdateWebsiteCommands): Observable<WebsiteActiveList>;
    get(id: number): Observable<WebsiteActiveList>;
}

@Injectable({
    providedIn: 'root'
})
export class WebsiteClient implements IWebsiteClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCollectionPointsQuery(offset: number | undefined, limit: number | undefined): Observable<PaginatedListOfWebsiteActiveList> {
        let url_ = this.baseUrl + "/api/Website?";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollectionPointsQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollectionPointsQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfWebsiteActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfWebsiteActiveList>;
        }));
    }

    protected processGetCollectionPointsQuery(response: HttpResponseBase): Observable<PaginatedListOfWebsiteActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfWebsiteActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateWebsiteCommands): Observable<WebsiteActiveList> {
        let url_ = this.baseUrl + "/api/Website";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebsiteActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebsiteActiveList>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WebsiteActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebsiteActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateWebsiteCommands): Observable<WebsiteActiveList> {
        let url_ = this.baseUrl + "/api/Website/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebsiteActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebsiteActiveList>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<WebsiteActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebsiteActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: number): Observable<WebsiteActiveList> {
        let url_ = this.baseUrl + "/api/Website/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebsiteActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebsiteActiveList>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WebsiteActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebsiteActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICollectionPointsClient {
    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCollectionPointInfo>;
    create(command: CreateCollectionPointCommand): Observable<number>;
    update(id: number, command: UpdateCollectionPointCommand): Observable<FileResponse>;
    get(id: number): Observable<CollectionPointInfo>;
}

@Injectable({
    providedIn: 'root'
})
export class CollectionPointsClient implements ICollectionPointsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCollectionPointInfo> {
        let url_ = this.baseUrl + "/api/CollectionPoints?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollectionPointsQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollectionPointsQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCollectionPointInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCollectionPointInfo>;
        }));
    }

    protected processGetCollectionPointsQuery(response: HttpResponseBase): Observable<PaginatedListOfCollectionPointInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCollectionPointInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCollectionPointCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CollectionPoints";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCollectionPointCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CollectionPoints/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: number): Observable<CollectionPointInfo> {
        let url_ = this.baseUrl + "/api/CollectionPoints/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CollectionPointInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CollectionPointInfo>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CollectionPointInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CollectionPointInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AuthenticationInfo implements IAuthenticationInfo {
    token?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IAuthenticationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): AuthenticationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IAuthenticationInfo {
    token?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class LoginCommand implements ILoginCommand {
    username?: string;
    password?: string;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginCommand {
    username?: string;
    password?: string;
}

export class LogoutCommand implements ILogoutCommand {
    visitorId?: string | undefined;

    constructor(data?: ILogoutCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.visitorId = _data["visitorId"];
        }
    }

    static fromJS(data: any): LogoutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visitorId"] = this.visitorId;
        return data;
    }
}

export interface ILogoutCommand {
    visitorId?: string | undefined;
}

export class Company implements ICompany {
    companyId?: number;
    companyName?: string;
    logoImage?: string;
    status?: string;
    createBy?: string;
    createDate?: any;
    updateBy?: string;
    updateDate?: any;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.logoImage = _data["logoImage"];
            this.status = _data["status"];
            this.createBy = _data["createBy"];
            this.createDate = _data["createDate"];
            this.updateBy = _data["updateBy"];
            this.updateDate = _data["updateDate"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["logoImage"] = this.logoImage;
        data["status"] = this.status;
        data["createBy"] = this.createBy;
        data["createDate"] = this.createDate;
        data["updateBy"] = this.updateBy;
        data["updateDate"] = this.updateDate;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICompany {
    companyId?: number;
    companyName?: string;
    logoImage?: string;
    status?: string;
    createBy?: string;
    createDate?: any;
    updateBy?: string;
    updateDate?: any;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class PaginatedListOfConsentTheme implements IPaginatedListOfConsentTheme {
    items?: ConsentTheme[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfConsentTheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ConsentTheme.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfConsentTheme {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfConsentTheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfConsentTheme {
    items?: ConsentTheme[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ConsentTheme implements IConsentTheme {
    themeId?: any;
    themeTitle?: string;
    status?: string;
    herderTextColor?: string;
    headerBackgroundColor?: string;
    bodyBackgroudColor?: string;
    topDescriptionTextColor?: string;
    bottomDescriptionTextColor?: string;
    acceptionConsentTextColor?: string;
    linkToPolicyTextColor?: string;
    acceptionButtonColor?: string;
    cancelButtonColor?: string;
    cancelTextButtonColor?: string;
    policyUrlTextColor?: string;
    companyId?: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IConsentTheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.themeId = _data["themeId"];
            this.themeTitle = _data["themeTitle"];
            this.status = _data["status"];
            this.herderTextColor = _data["herderTextColor"];
            this.headerBackgroundColor = _data["headerBackgroundColor"];
            this.bodyBackgroudColor = _data["bodyBackgroudColor"];
            this.topDescriptionTextColor = _data["topDescriptionTextColor"];
            this.bottomDescriptionTextColor = _data["bottomDescriptionTextColor"];
            this.acceptionConsentTextColor = _data["acceptionConsentTextColor"];
            this.linkToPolicyTextColor = _data["linkToPolicyTextColor"];
            this.acceptionButtonColor = _data["acceptionButtonColor"];
            this.cancelButtonColor = _data["cancelButtonColor"];
            this.cancelTextButtonColor = _data["cancelTextButtonColor"];
            this.policyUrlTextColor = _data["policyUrlTextColor"];
            this.companyId = _data["companyId"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ConsentTheme {
        data = typeof data === 'object' ? data : {};
        let result = new ConsentTheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["themeId"] = this.themeId;
        data["themeTitle"] = this.themeTitle;
        data["status"] = this.status;
        data["herderTextColor"] = this.herderTextColor;
        data["headerBackgroundColor"] = this.headerBackgroundColor;
        data["bodyBackgroudColor"] = this.bodyBackgroudColor;
        data["topDescriptionTextColor"] = this.topDescriptionTextColor;
        data["bottomDescriptionTextColor"] = this.bottomDescriptionTextColor;
        data["acceptionConsentTextColor"] = this.acceptionConsentTextColor;
        data["linkToPolicyTextColor"] = this.linkToPolicyTextColor;
        data["acceptionButtonColor"] = this.acceptionButtonColor;
        data["cancelButtonColor"] = this.cancelButtonColor;
        data["cancelTextButtonColor"] = this.cancelTextButtonColor;
        data["policyUrlTextColor"] = this.policyUrlTextColor;
        data["companyId"] = this.companyId;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IConsentTheme {
    themeId?: any;
    themeTitle?: string;
    status?: string;
    herderTextColor?: string;
    headerBackgroundColor?: string;
    bodyBackgroudColor?: string;
    topDescriptionTextColor?: string;
    bottomDescriptionTextColor?: string;
    acceptionConsentTextColor?: string;
    linkToPolicyTextColor?: string;
    acceptionButtonColor?: string;
    cancelButtonColor?: string;
    cancelTextButtonColor?: string;
    policyUrlTextColor?: string;
    companyId?: number;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CreateConsentThemeCommand implements ICreateConsentThemeCommand {
    themeTitle?: string;
    headerTextColor?: string;
    headerBackgroundColor?: string;
    bodyBackgroudColor?: string;
    topDescriptionTextColor?: string;
    bottomDescriptionTextColor?: string;
    acceptionButtonColor?: string;
    acceptionConsentTextColor?: string;
    cancelButtonColor?: string;
    cancelTextButtonColor?: string;
    linkToPolicyTextColor?: string;
    policyUrlTextColor?: string;

    constructor(data?: ICreateConsentThemeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.themeTitle = _data["themeTitle"];
            this.headerTextColor = _data["headerTextColor"];
            this.headerBackgroundColor = _data["headerBackgroundColor"];
            this.bodyBackgroudColor = _data["bodyBackgroudColor"];
            this.topDescriptionTextColor = _data["topDescriptionTextColor"];
            this.bottomDescriptionTextColor = _data["bottomDescriptionTextColor"];
            this.acceptionButtonColor = _data["acceptionButtonColor"];
            this.acceptionConsentTextColor = _data["acceptionConsentTextColor"];
            this.cancelButtonColor = _data["cancelButtonColor"];
            this.cancelTextButtonColor = _data["cancelTextButtonColor"];
            this.linkToPolicyTextColor = _data["linkToPolicyTextColor"];
            this.policyUrlTextColor = _data["policyUrlTextColor"];
        }
    }

    static fromJS(data: any): CreateConsentThemeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConsentThemeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["themeTitle"] = this.themeTitle;
        data["headerTextColor"] = this.headerTextColor;
        data["headerBackgroundColor"] = this.headerBackgroundColor;
        data["bodyBackgroudColor"] = this.bodyBackgroudColor;
        data["topDescriptionTextColor"] = this.topDescriptionTextColor;
        data["bottomDescriptionTextColor"] = this.bottomDescriptionTextColor;
        data["acceptionButtonColor"] = this.acceptionButtonColor;
        data["acceptionConsentTextColor"] = this.acceptionConsentTextColor;
        data["cancelButtonColor"] = this.cancelButtonColor;
        data["cancelTextButtonColor"] = this.cancelTextButtonColor;
        data["linkToPolicyTextColor"] = this.linkToPolicyTextColor;
        data["policyUrlTextColor"] = this.policyUrlTextColor;
        return data;
    }
}

export interface ICreateConsentThemeCommand {
    themeTitle?: string;
    headerTextColor?: string;
    headerBackgroundColor?: string;
    bodyBackgroudColor?: string;
    topDescriptionTextColor?: string;
    bottomDescriptionTextColor?: string;
    acceptionButtonColor?: string;
    acceptionConsentTextColor?: string;
    cancelButtonColor?: string;
    cancelTextButtonColor?: string;
    linkToPolicyTextColor?: string;
    policyUrlTextColor?: string;
}

export class UpdateConsentThemeCommand implements IUpdateConsentThemeCommand {
    themeTitle?: string;
    headerTextColor?: string;
    headerBackgroundColor?: string;
    bodyBackgroudColor?: string;
    topDescriptionTextColor?: string;
    bottomDescriptionTextColor?: string;
    acceptionButtonColor?: string;
    acceptionConsentTextColor?: string;
    cancelButtonColor?: string;
    cancelTextButtonColor?: string;
    linkToPolicyTextColor?: string;
    policyUrlTextColor?: string;

    constructor(data?: IUpdateConsentThemeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.themeTitle = _data["themeTitle"];
            this.headerTextColor = _data["headerTextColor"];
            this.headerBackgroundColor = _data["headerBackgroundColor"];
            this.bodyBackgroudColor = _data["bodyBackgroudColor"];
            this.topDescriptionTextColor = _data["topDescriptionTextColor"];
            this.bottomDescriptionTextColor = _data["bottomDescriptionTextColor"];
            this.acceptionButtonColor = _data["acceptionButtonColor"];
            this.acceptionConsentTextColor = _data["acceptionConsentTextColor"];
            this.cancelButtonColor = _data["cancelButtonColor"];
            this.cancelTextButtonColor = _data["cancelTextButtonColor"];
            this.linkToPolicyTextColor = _data["linkToPolicyTextColor"];
            this.policyUrlTextColor = _data["policyUrlTextColor"];
        }
    }

    static fromJS(data: any): UpdateConsentThemeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateConsentThemeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["themeTitle"] = this.themeTitle;
        data["headerTextColor"] = this.headerTextColor;
        data["headerBackgroundColor"] = this.headerBackgroundColor;
        data["bodyBackgroudColor"] = this.bodyBackgroudColor;
        data["topDescriptionTextColor"] = this.topDescriptionTextColor;
        data["bottomDescriptionTextColor"] = this.bottomDescriptionTextColor;
        data["acceptionButtonColor"] = this.acceptionButtonColor;
        data["acceptionConsentTextColor"] = this.acceptionConsentTextColor;
        data["cancelButtonColor"] = this.cancelButtonColor;
        data["cancelTextButtonColor"] = this.cancelTextButtonColor;
        data["linkToPolicyTextColor"] = this.linkToPolicyTextColor;
        data["policyUrlTextColor"] = this.policyUrlTextColor;
        return data;
    }
}

export interface IUpdateConsentThemeCommand {
    themeTitle?: string;
    headerTextColor?: string;
    headerBackgroundColor?: string;
    bodyBackgroudColor?: string;
    topDescriptionTextColor?: string;
    bottomDescriptionTextColor?: string;
    acceptionButtonColor?: string;
    acceptionConsentTextColor?: string;
    cancelButtonColor?: string;
    cancelTextButtonColor?: string;
    linkToPolicyTextColor?: string;
    policyUrlTextColor?: string;
}

export class ShortUrl implements IShortUrl {
    url?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IShortUrl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ShortUrl {
        data = typeof data === 'object' ? data : {};
        let result = new ShortUrl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IShortUrl {
    url?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class Image implements IImage {
    fullPath?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullPath = _data["fullPath"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Image {
        data = typeof data === 'object' ? data : {};
        let result = new Image();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullPath"] = this.fullPath;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IImage {
    fullPath?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class PaginatedListOfCollectionPointCustomFieldActiveList implements IPaginatedListOfCollectionPointCustomFieldActiveList {
    items?: CollectionPointCustomFieldActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCollectionPointCustomFieldActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CollectionPointCustomFieldActiveList.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCollectionPointCustomFieldActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCollectionPointCustomFieldActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCollectionPointCustomFieldActiveList {
    items?: CollectionPointCustomFieldActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CollectionPointCustomFieldActiveList implements ICollectionPointCustomFieldActiveList {
    id?: number;
    code?: string;
    owner?: string;
    inputType?: string;
    title?: string;
    placeholder?: string;
    lengthLimit?: number;
    maxLines?: number;
    minLines?: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointCustomFieldActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.owner = _data["owner"];
            this.inputType = _data["inputType"];
            this.title = _data["title"];
            this.placeholder = _data["placeholder"];
            this.lengthLimit = _data["lengthLimit"];
            this.maxLines = _data["maxLines"];
            this.minLines = _data["minLines"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointCustomFieldActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointCustomFieldActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["owner"] = this.owner;
        data["inputType"] = this.inputType;
        data["title"] = this.title;
        data["placeholder"] = this.placeholder;
        data["lengthLimit"] = this.lengthLimit;
        data["maxLines"] = this.maxLines;
        data["minLines"] = this.minLines;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointCustomFieldActiveList {
    id?: number;
    code?: string;
    owner?: string;
    inputType?: string;
    title?: string;
    placeholder?: string;
    lengthLimit?: number;
    maxLines?: number;
    minLines?: number;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CreateCustomFieldCommand implements ICreateCustomFieldCommand {
    code?: string;
    owner?: string;
    inputType?: string;
    title?: string;
    placeholder?: string;
    lengthLimit?: number;
    maxLines?: number;
    minLines?: number;

    constructor(data?: ICreateCustomFieldCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.owner = _data["owner"];
            this.inputType = _data["inputType"];
            this.title = _data["title"];
            this.placeholder = _data["placeholder"];
            this.lengthLimit = _data["lengthLimit"];
            this.maxLines = _data["maxLines"];
            this.minLines = _data["minLines"];
        }
    }

    static fromJS(data: any): CreateCustomFieldCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomFieldCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["owner"] = this.owner;
        data["inputType"] = this.inputType;
        data["title"] = this.title;
        data["placeholder"] = this.placeholder;
        data["lengthLimit"] = this.lengthLimit;
        data["maxLines"] = this.maxLines;
        data["minLines"] = this.minLines;
        return data;
    }
}

export interface ICreateCustomFieldCommand {
    code?: string;
    owner?: string;
    inputType?: string;
    title?: string;
    placeholder?: string;
    lengthLimit?: number;
    maxLines?: number;
    minLines?: number;
}

export class UpdateCustomFieldCommand implements IUpdateCustomFieldCommand {
    id?: number;
    code?: string;
    owner?: string;
    inputType?: string;
    title?: string;
    placeholder?: string;
    lengthLimit?: number;
    maxLines?: number;
    minLines?: number;

    constructor(data?: IUpdateCustomFieldCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.owner = _data["owner"];
            this.inputType = _data["inputType"];
            this.title = _data["title"];
            this.placeholder = _data["placeholder"];
            this.lengthLimit = _data["lengthLimit"];
            this.maxLines = _data["maxLines"];
            this.minLines = _data["minLines"];
        }
    }

    static fromJS(data: any): UpdateCustomFieldCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomFieldCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["owner"] = this.owner;
        data["inputType"] = this.inputType;
        data["title"] = this.title;
        data["placeholder"] = this.placeholder;
        data["lengthLimit"] = this.lengthLimit;
        data["maxLines"] = this.maxLines;
        data["minLines"] = this.minLines;
        return data;
    }
}

export interface IUpdateCustomFieldCommand {
    id?: number;
    code?: string;
    owner?: string;
    inputType?: string;
    title?: string;
    placeholder?: string;
    lengthLimit?: number;
    maxLines?: number;
    minLines?: number;
}

export class PaginatedListOfGeneralConsent implements IPaginatedListOfGeneralConsent {
    items?: GeneralConsent[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfGeneralConsent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GeneralConsent.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfGeneralConsent {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfGeneralConsent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfGeneralConsent {
    items?: GeneralConsent[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GeneralConsent implements IGeneralConsent {
    consentId?: number;
    collectionPointId?: number;
    uid?: number;
    totalTransactions?: number;
    fullName?: string;
    collectionPointGuid?: string;
    consentDateTime?: string;
    website?: Website4;
    collectionPointVersion?: number;
    purposeList?: GeneralConsentPurpose[];
    fromBrowser?: string;
    phoneNumber?: string;
    idCardNumber?: string;
    email?: string;
    remark?: string;
    totalCount?: number;
    companyId?: number;
    companyName?: string;
    status?: string;
    verifyType?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IGeneralConsent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consentId = _data["consentId"];
            this.collectionPointId = _data["collectionPointId"];
            this.uid = _data["uid"];
            this.totalTransactions = _data["totalTransactions"];
            this.fullName = _data["fullName"];
            this.collectionPointGuid = _data["collectionPointGuid"];
            this.consentDateTime = _data["consentDateTime"];
            this.website = _data["website"] ? Website4.fromJS(_data["website"]) : <any>undefined;
            this.collectionPointVersion = _data["collectionPointVersion"];
            if (Array.isArray(_data["purposeList"])) {
                this.purposeList = [] as any;
                for (let item of _data["purposeList"])
                    this.purposeList!.push(GeneralConsentPurpose.fromJS(item));
            }
            this.fromBrowser = _data["fromBrowser"];
            this.phoneNumber = _data["phoneNumber"];
            this.idCardNumber = _data["idCardNumber"];
            this.email = _data["email"];
            this.remark = _data["remark"];
            this.totalCount = _data["totalCount"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.status = _data["status"];
            this.verifyType = _data["verifyType"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): GeneralConsent {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralConsent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consentId"] = this.consentId;
        data["collectionPointId"] = this.collectionPointId;
        data["uid"] = this.uid;
        data["totalTransactions"] = this.totalTransactions;
        data["fullName"] = this.fullName;
        data["collectionPointGuid"] = this.collectionPointGuid;
        data["consentDateTime"] = this.consentDateTime;
        data["website"] = this.website ? this.website.toJSON() : <any>undefined;
        data["collectionPointVersion"] = this.collectionPointVersion;
        if (Array.isArray(this.purposeList)) {
            data["purposeList"] = [];
            for (let item of this.purposeList)
                data["purposeList"].push(item.toJSON());
        }
        data["fromBrowser"] = this.fromBrowser;
        data["phoneNumber"] = this.phoneNumber;
        data["idCardNumber"] = this.idCardNumber;
        data["email"] = this.email;
        data["remark"] = this.remark;
        data["totalCount"] = this.totalCount;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["status"] = this.status;
        data["verifyType"] = this.verifyType;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IGeneralConsent {
    consentId?: number;
    collectionPointId?: number;
    uid?: number;
    totalTransactions?: number;
    fullName?: string;
    collectionPointGuid?: string;
    consentDateTime?: string;
    website?: Website4;
    collectionPointVersion?: number;
    purposeList?: GeneralConsentPurpose[];
    fromBrowser?: string;
    phoneNumber?: string;
    idCardNumber?: string;
    email?: string;
    remark?: string;
    totalCount?: number;
    companyId?: number;
    companyName?: string;
    status?: string;
    verifyType?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class Website4 implements IWebsite4 {
    id?: number;
    description?: string;
    urlPolicyPage?: string;
    urlHomePage?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IWebsite4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.urlPolicyPage = _data["urlPolicyPage"];
            this.urlHomePage = _data["urlHomePage"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Website4 {
        data = typeof data === 'object' ? data : {};
        let result = new Website4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["urlPolicyPage"] = this.urlPolicyPage;
        data["urlHomePage"] = this.urlHomePage;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IWebsite4 {
    id?: number;
    description?: string;
    urlPolicyPage?: string;
    urlHomePage?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class GeneralConsentPurpose implements IGeneralConsentPurpose {
    purposeId?: number;
    companyId?: number;
    code?: string;
    description?: string;
    warningDescription?: string;
    purposeCategoryId?: number;
    expiredDateTime?: string;
    guid?: string;
    version?: number;
    priority?: number;
    status?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IGeneralConsentPurpose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purposeId = _data["purposeId"];
            this.companyId = _data["companyId"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.warningDescription = _data["warningDescription"];
            this.purposeCategoryId = _data["purposeCategoryId"];
            this.expiredDateTime = _data["expiredDateTime"];
            this.guid = _data["guid"];
            this.version = _data["version"];
            this.priority = _data["priority"];
            this.status = _data["status"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): GeneralConsentPurpose {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralConsentPurpose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purposeId"] = this.purposeId;
        data["companyId"] = this.companyId;
        data["code"] = this.code;
        data["description"] = this.description;
        data["warningDescription"] = this.warningDescription;
        data["purposeCategoryId"] = this.purposeCategoryId;
        data["expiredDateTime"] = this.expiredDateTime;
        data["guid"] = this.guid;
        data["version"] = this.version;
        data["priority"] = this.priority;
        data["status"] = this.status;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IGeneralConsentPurpose {
    purposeId?: number;
    companyId?: number;
    code?: string;
    description?: string;
    warningDescription?: string;
    purposeCategoryId?: number;
    expiredDateTime?: string;
    guid?: string;
    version?: number;
    priority?: number;
    status?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class SubmitConsentCommand implements ISubmitConsentCommand {
    ageRangeCode?: string;
    collectionPointGuid?: string;
    companyId?: number;
    webSiteId?: number;
    uid?: number;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    fromBrowser?: string;
    fromWebsite?: string;
    verifyType?: string;
    eventCode?: string;
    idCardNumber?: string;
    expiredDateTime?: Date;
    consentSignature?: string;
    purpose?: SubmitConsentPurpose[];
    collectionPointCustomField?: SubmitCollectionPointCustomField[];

    constructor(data?: ISubmitConsentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ageRangeCode = _data["ageRangeCode"];
            this.collectionPointGuid = _data["collectionPointGuid"];
            this.companyId = _data["companyId"];
            this.webSiteId = _data["webSiteId"];
            this.uid = _data["uid"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.fromBrowser = _data["fromBrowser"];
            this.fromWebsite = _data["fromWebsite"];
            this.verifyType = _data["verifyType"];
            this.eventCode = _data["eventCode"];
            this.idCardNumber = _data["idCardNumber"];
            this.expiredDateTime = _data["expiredDateTime"] ? new Date(_data["expiredDateTime"].toString()) : <any>undefined;
            this.consentSignature = _data["consentSignature"];
            if (Array.isArray(_data["purpose"])) {
                this.purpose = [] as any;
                for (let item of _data["purpose"])
                    this.purpose!.push(SubmitConsentPurpose.fromJS(item));
            }
            if (Array.isArray(_data["collectionPointCustomField"])) {
                this.collectionPointCustomField = [] as any;
                for (let item of _data["collectionPointCustomField"])
                    this.collectionPointCustomField!.push(SubmitCollectionPointCustomField.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitConsentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitConsentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ageRangeCode"] = this.ageRangeCode;
        data["collectionPointGuid"] = this.collectionPointGuid;
        data["companyId"] = this.companyId;
        data["webSiteId"] = this.webSiteId;
        data["uid"] = this.uid;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["fromBrowser"] = this.fromBrowser;
        data["fromWebsite"] = this.fromWebsite;
        data["verifyType"] = this.verifyType;
        data["eventCode"] = this.eventCode;
        data["idCardNumber"] = this.idCardNumber;
        data["expiredDateTime"] = this.expiredDateTime ? this.expiredDateTime.toISOString() : <any>undefined;
        data["consentSignature"] = this.consentSignature;
        if (Array.isArray(this.purpose)) {
            data["purpose"] = [];
            for (let item of this.purpose)
                data["purpose"].push(item.toJSON());
        }
        if (Array.isArray(this.collectionPointCustomField)) {
            data["collectionPointCustomField"] = [];
            for (let item of this.collectionPointCustomField)
                data["collectionPointCustomField"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubmitConsentCommand {
    ageRangeCode?: string;
    collectionPointGuid?: string;
    companyId?: number;
    webSiteId?: number;
    uid?: number;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    fromBrowser?: string;
    fromWebsite?: string;
    verifyType?: string;
    eventCode?: string;
    idCardNumber?: string;
    expiredDateTime?: Date;
    consentSignature?: string;
    purpose?: SubmitConsentPurpose[];
    collectionPointCustomField?: SubmitCollectionPointCustomField[];
}

export class SubmitConsentPurpose implements ISubmitConsentPurpose {
    purposeGuid!: string;
    active?: boolean;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ISubmitConsentPurpose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purposeGuid = _data["purposeGuid"];
            this.active = _data["active"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SubmitConsentPurpose {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitConsentPurpose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purposeGuid"] = this.purposeGuid;
        data["active"] = this.active;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ISubmitConsentPurpose {
    purposeGuid: string;
    active?: boolean;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class SubmitCollectionPointCustomField implements ISubmitCollectionPointCustomField {
    collectionPointCustomFieldConfigId?: number;
    value?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ISubmitCollectionPointCustomField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collectionPointCustomFieldConfigId = _data["collectionPointCustomFieldConfigId"];
            this.value = _data["value"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SubmitCollectionPointCustomField {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitCollectionPointCustomField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionPointCustomFieldConfigId"] = this.collectionPointCustomFieldConfigId;
        data["value"] = this.value;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ISubmitCollectionPointCustomField {
    collectionPointCustomFieldConfigId?: number;
    value?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class GetLatestIdRequestQuery implements IGetLatestIdRequestQuery {
    idCardNumber?: string;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    collectionPointGuid?: string;

    constructor(data?: IGetLatestIdRequestQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idCardNumber = _data["idCardNumber"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.collectionPointGuid = _data["collectionPointGuid"];
        }
    }

    static fromJS(data: any): GetLatestIdRequestQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestIdRequestQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idCardNumber"] = this.idCardNumber;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["collectionPointGuid"] = this.collectionPointGuid;
        return data;
    }
}

export interface IGetLatestIdRequestQuery {
    idCardNumber?: string;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    collectionPointGuid?: string;
}

export class GeneralConsentInfoRequestQuery implements IGeneralConsentInfoRequestQuery {
    idCardNumber?: string;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    collectionPointGuid?: string;

    constructor(data?: IGeneralConsentInfoRequestQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idCardNumber = _data["idCardNumber"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.collectionPointGuid = _data["collectionPointGuid"];
        }
    }

    static fromJS(data: any): GeneralConsentInfoRequestQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralConsentInfoRequestQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idCardNumber"] = this.idCardNumber;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["collectionPointGuid"] = this.collectionPointGuid;
        return data;
    }
}

export interface IGeneralConsentInfoRequestQuery {
    idCardNumber?: string;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    collectionPointGuid?: string;
}

export class PaginatedListOfPurposeCategoryActiveList implements IPaginatedListOfPurposeCategoryActiveList {
    items?: PurposeCategoryActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfPurposeCategoryActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PurposeCategoryActiveList.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfPurposeCategoryActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPurposeCategoryActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfPurposeCategoryActiveList {
    items?: PurposeCategoryActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PurposeCategoryActiveList implements IPurposeCategoryActiveList {
    code?: string;
    description?: string;
    language?: string;
    status?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IPurposeCategoryActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
            this.language = _data["language"];
            this.status = _data["status"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PurposeCategoryActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PurposeCategoryActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["language"] = this.language;
        data["status"] = this.status;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IPurposeCategoryActiveList {
    code?: string;
    description?: string;
    language?: string;
    status?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CreatePurposeCategoryCommand implements ICreatePurposeCategoryCommand {
    code?: string;
    description?: string;

    constructor(data?: ICreatePurposeCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreatePurposeCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurposeCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreatePurposeCategoryCommand {
    code?: string;
    description?: string;
}

export class UpdatePurposeCategoryCommand implements IUpdatePurposeCategoryCommand {
    id?: number;
    description?: string;
    status?: string;

    constructor(data?: IUpdatePurposeCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdatePurposeCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurposeCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdatePurposeCategoryCommand {
    id?: number;
    description?: string;
    status?: string;
}

export class PaginatedListOfPurposeActiveList implements IPaginatedListOfPurposeActiveList {
    items?: PurposeActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfPurposeActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PurposeActiveList.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfPurposeActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPurposeActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfPurposeActiveList {
    items?: PurposeActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PurposeActiveList implements IPurposeActiveList {
    purposeID?: number;
    guid?: string;
    purposeType?: number;
    categoryID?: number;
    code?: string;
    description?: string;
    keepAliveData?: string;
    linkMoreDetail?: string;
    status?: string;
    textMoreDetail?: string;
    warningDescription?: string;
    expiredDateTime?: string;
    language?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IPurposeActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purposeID = _data["purposeID"];
            this.guid = _data["guid"];
            this.purposeType = _data["purposeType"];
            this.categoryID = _data["categoryID"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.keepAliveData = _data["keepAliveData"];
            this.linkMoreDetail = _data["linkMoreDetail"];
            this.status = _data["status"];
            this.textMoreDetail = _data["textMoreDetail"];
            this.warningDescription = _data["warningDescription"];
            this.expiredDateTime = _data["expiredDateTime"];
            this.language = _data["language"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PurposeActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PurposeActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purposeID"] = this.purposeID;
        data["guid"] = this.guid;
        data["purposeType"] = this.purposeType;
        data["categoryID"] = this.categoryID;
        data["code"] = this.code;
        data["description"] = this.description;
        data["keepAliveData"] = this.keepAliveData;
        data["linkMoreDetail"] = this.linkMoreDetail;
        data["status"] = this.status;
        data["textMoreDetail"] = this.textMoreDetail;
        data["warningDescription"] = this.warningDescription;
        data["expiredDateTime"] = this.expiredDateTime;
        data["language"] = this.language;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IPurposeActiveList {
    purposeID?: number;
    guid?: string;
    purposeType?: number;
    categoryID?: number;
    code?: string;
    description?: string;
    keepAliveData?: string;
    linkMoreDetail?: string;
    status?: string;
    textMoreDetail?: string;
    warningDescription?: string;
    expiredDateTime?: string;
    language?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CreatePurposeCommand implements ICreatePurposeCommand {
    purposeType?: number;
    categoryID?: number;
    code?: string;
    description?: string;
    keepAliveData?: string;
    linkMoreDetail?: string;
    status?: string;
    textMoreDetail?: string;
    warningDescription?: string;

    constructor(data?: ICreatePurposeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purposeType = _data["purposeType"];
            this.categoryID = _data["categoryID"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.keepAliveData = _data["keepAliveData"];
            this.linkMoreDetail = _data["linkMoreDetail"];
            this.status = _data["status"];
            this.textMoreDetail = _data["textMoreDetail"];
            this.warningDescription = _data["warningDescription"];
        }
    }

    static fromJS(data: any): CreatePurposeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurposeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purposeType"] = this.purposeType;
        data["categoryID"] = this.categoryID;
        data["code"] = this.code;
        data["description"] = this.description;
        data["keepAliveData"] = this.keepAliveData;
        data["linkMoreDetail"] = this.linkMoreDetail;
        data["status"] = this.status;
        data["textMoreDetail"] = this.textMoreDetail;
        data["warningDescription"] = this.warningDescription;
        return data;
    }
}

export interface ICreatePurposeCommand {
    purposeType?: number;
    categoryID?: number;
    code?: string;
    description?: string;
    keepAliveData?: string;
    linkMoreDetail?: string;
    status?: string;
    textMoreDetail?: string;
    warningDescription?: string;
}

export class UpdatePurposeCommand implements IUpdatePurposeCommand {
    purposeID?: number;
    purposeType?: number;
    categoryID?: number;
    description?: string;
    keepAliveData?: string;
    linkMoreDetail?: string;
    status?: string;
    textMoreDetail?: string;
    warningDescription?: string;

    constructor(data?: IUpdatePurposeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purposeID = _data["purposeID"];
            this.purposeType = _data["purposeType"];
            this.categoryID = _data["categoryID"];
            this.description = _data["description"];
            this.keepAliveData = _data["keepAliveData"];
            this.linkMoreDetail = _data["linkMoreDetail"];
            this.status = _data["status"];
            this.textMoreDetail = _data["textMoreDetail"];
            this.warningDescription = _data["warningDescription"];
        }
    }

    static fromJS(data: any): UpdatePurposeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurposeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purposeID"] = this.purposeID;
        data["purposeType"] = this.purposeType;
        data["categoryID"] = this.categoryID;
        data["description"] = this.description;
        data["keepAliveData"] = this.keepAliveData;
        data["linkMoreDetail"] = this.linkMoreDetail;
        data["status"] = this.status;
        data["textMoreDetail"] = this.textMoreDetail;
        data["warningDescription"] = this.warningDescription;
        return data;
    }
}

export interface IUpdatePurposeCommand {
    purposeID?: number;
    purposeType?: number;
    categoryID?: number;
    description?: string;
    keepAliveData?: string;
    linkMoreDetail?: string;
    status?: string;
    textMoreDetail?: string;
    warningDescription?: string;
}

export class PaginatedListOfSectionActiveList implements IPaginatedListOfSectionActiveList {
    items?: SectionActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfSectionActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SectionActiveList.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfSectionActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSectionActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfSectionActiveList {
    items?: SectionActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SectionActiveList implements ISectionActiveList {
    sectionId?: number;
    code?: string;
    description?: string;
    status?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ISectionActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sectionId = _data["sectionId"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.status = _data["status"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SectionActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new SectionActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectionId"] = this.sectionId;
        data["code"] = this.code;
        data["description"] = this.description;
        data["status"] = this.status;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ISectionActiveList {
    sectionId?: number;
    code?: string;
    description?: string;
    status?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CreateSectionCommand implements ICreateSectionCommand {
    code?: string;
    description?: string;
    status?: string;

    constructor(data?: ICreateSectionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateSectionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSectionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateSectionCommand {
    code?: string;
    description?: string;
    status?: string;
}

export class UpdateSectionCommand implements IUpdateSectionCommand {
    id?: number;
    code?: string;
    description?: string;
    status?: string;

    constructor(data?: IUpdateSectionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateSectionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSectionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["description"] = this.description;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateSectionCommand {
    id?: number;
    code?: string;
    description?: string;
    status?: string;
}

export class UserInfo implements IUserInfo {
    address?: string;
    birthDate?: string;
    citizenId?: string;
    companyId?: number;
    email?: string;
    fullName?: string;
    guid?: string;
    gender?: string;
    positionDescription?: string;
    profileImage?: string;
    tel?: string;
    userID?: number;
    username?: string;
    version?: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.birthDate = _data["birthDate"];
            this.citizenId = _data["citizenId"];
            this.companyId = _data["companyId"];
            this.email = _data["email"];
            this.fullName = _data["fullName"];
            this.guid = _data["guid"];
            this.gender = _data["gender"];
            this.positionDescription = _data["positionDescription"];
            this.profileImage = _data["profileImage"];
            this.tel = _data["tel"];
            this.userID = _data["userID"];
            this.username = _data["username"];
            this.version = _data["version"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["birthDate"] = this.birthDate;
        data["citizenId"] = this.citizenId;
        data["companyId"] = this.companyId;
        data["email"] = this.email;
        data["fullName"] = this.fullName;
        data["guid"] = this.guid;
        data["gender"] = this.gender;
        data["positionDescription"] = this.positionDescription;
        data["profileImage"] = this.profileImage;
        data["tel"] = this.tel;
        data["userID"] = this.userID;
        data["username"] = this.username;
        data["version"] = this.version;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IUserInfo {
    address?: string;
    birthDate?: string;
    citizenId?: string;
    companyId?: number;
    email?: string;
    fullName?: string;
    guid?: string;
    gender?: string;
    positionDescription?: string;
    profileImage?: string;
    tel?: string;
    userID?: number;
    username?: string;
    version?: number;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class PaginatedListOfWebsiteActiveList implements IPaginatedListOfWebsiteActiveList {
    items?: WebsiteActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfWebsiteActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WebsiteActiveList.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfWebsiteActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfWebsiteActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfWebsiteActiveList {
    items?: WebsiteActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WebsiteActiveList implements IWebsiteActiveList {
    websiteId?: number;
    name?: string;
    urlHomePage?: string;
    urlPolicyPage?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IWebsiteActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.websiteId = _data["websiteId"];
            this.name = _data["name"];
            this.urlHomePage = _data["urlHomePage"];
            this.urlPolicyPage = _data["urlPolicyPage"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): WebsiteActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new WebsiteActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["websiteId"] = this.websiteId;
        data["name"] = this.name;
        data["urlHomePage"] = this.urlHomePage;
        data["urlPolicyPage"] = this.urlPolicyPage;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IWebsiteActiveList {
    websiteId?: number;
    name?: string;
    urlHomePage?: string;
    urlPolicyPage?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CreateWebsiteCommands implements ICreateWebsiteCommands {
    name?: string;
    urlHomePage?: string;
    urlPolicyPage?: string;
    status?: string;

    constructor(data?: ICreateWebsiteCommands) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.urlHomePage = _data["urlHomePage"];
            this.urlPolicyPage = _data["urlPolicyPage"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateWebsiteCommands {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWebsiteCommands();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["urlHomePage"] = this.urlHomePage;
        data["urlPolicyPage"] = this.urlPolicyPage;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateWebsiteCommands {
    name?: string;
    urlHomePage?: string;
    urlPolicyPage?: string;
    status?: string;
}

export class UpdateWebsiteCommands implements IUpdateWebsiteCommands {
    websiteId?: number;
    name?: string;
    urlHomePage?: string;
    urlPolicyPage?: string;
    status?: string;

    constructor(data?: IUpdateWebsiteCommands) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.websiteId = _data["websiteId"];
            this.name = _data["name"];
            this.urlHomePage = _data["urlHomePage"];
            this.urlPolicyPage = _data["urlPolicyPage"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateWebsiteCommands {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWebsiteCommands();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["websiteId"] = this.websiteId;
        data["name"] = this.name;
        data["urlHomePage"] = this.urlHomePage;
        data["urlPolicyPage"] = this.urlPolicyPage;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateWebsiteCommands {
    websiteId?: number;
    name?: string;
    urlHomePage?: string;
    urlPolicyPage?: string;
    status?: string;
}

export class PaginatedListOfCollectionPointInfo implements IPaginatedListOfCollectionPointInfo {
    items?: CollectionPointInfo[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCollectionPointInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CollectionPointInfo.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCollectionPointInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCollectionPointInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCollectionPointInfo {
    items?: CollectionPointInfo[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CollectionPointInfo implements ICollectionPointInfo {
    collectionPointId?: number;
    collectionPointName?: string;
    guid?: string;
    website?: Website;
    purposeList?: GeneralConsentPurpose[];
    customFieldsList?: CustomFields[];
    expiredDateTime?: string;
    companyId?: number;
    version?: number;
    status?: string;
    pageDetail?: CollectionPointPageDetail;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collectionPointId = _data["collectionPointId"];
            this.collectionPointName = _data["collectionPointName"];
            this.guid = _data["guid"];
            this.website = _data["website"] ? Website.fromJS(_data["website"]) : <any>undefined;
            if (Array.isArray(_data["purposeList"])) {
                this.purposeList = [] as any;
                for (let item of _data["purposeList"])
                    this.purposeList!.push(GeneralConsentPurpose.fromJS(item));
            }
            if (Array.isArray(_data["customFieldsList"])) {
                this.customFieldsList = [] as any;
                for (let item of _data["customFieldsList"])
                    this.customFieldsList!.push(CustomFields.fromJS(item));
            }
            this.expiredDateTime = _data["expiredDateTime"];
            this.companyId = _data["companyId"];
            this.version = _data["version"];
            this.status = _data["status"];
            this.pageDetail = _data["pageDetail"] ? CollectionPointPageDetail.fromJS(_data["pageDetail"]) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionPointId"] = this.collectionPointId;
        data["collectionPointName"] = this.collectionPointName;
        data["guid"] = this.guid;
        data["website"] = this.website ? this.website.toJSON() : <any>undefined;
        if (Array.isArray(this.purposeList)) {
            data["purposeList"] = [];
            for (let item of this.purposeList)
                data["purposeList"].push(item.toJSON());
        }
        if (Array.isArray(this.customFieldsList)) {
            data["customFieldsList"] = [];
            for (let item of this.customFieldsList)
                data["customFieldsList"].push(item.toJSON());
        }
        data["expiredDateTime"] = this.expiredDateTime;
        data["companyId"] = this.companyId;
        data["version"] = this.version;
        data["status"] = this.status;
        data["pageDetail"] = this.pageDetail ? this.pageDetail.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointInfo {
    collectionPointId?: number;
    collectionPointName?: string;
    guid?: string;
    website?: Website;
    purposeList?: GeneralConsentPurpose[];
    customFieldsList?: CustomFields[];
    expiredDateTime?: string;
    companyId?: number;
    version?: number;
    status?: string;
    pageDetail?: CollectionPointPageDetail;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class Website implements IWebsite {
    id?: number;
    description?: string;
    urlPolicyPage?: string;
    urlHomePage?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IWebsite) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.urlPolicyPage = _data["urlPolicyPage"];
            this.urlHomePage = _data["urlHomePage"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Website {
        data = typeof data === 'object' ? data : {};
        let result = new Website();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["urlPolicyPage"] = this.urlPolicyPage;
        data["urlHomePage"] = this.urlHomePage;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IWebsite {
    id?: number;
    description?: string;
    urlPolicyPage?: string;
    urlHomePage?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CustomFields implements ICustomFields {
    id?: number;
    isRequired?: boolean;
    sequence?: number;
    inputType?: string;
    title?: string;
    placeholder?: string;
    lengthLimit?: number;
    maxLines?: number;
    minLines?: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICustomFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isRequired = _data["isRequired"];
            this.sequence = _data["sequence"];
            this.inputType = _data["inputType"];
            this.title = _data["title"];
            this.placeholder = _data["placeholder"];
            this.lengthLimit = _data["lengthLimit"];
            this.maxLines = _data["maxLines"];
            this.minLines = _data["minLines"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CustomFields {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isRequired"] = this.isRequired;
        data["sequence"] = this.sequence;
        data["inputType"] = this.inputType;
        data["title"] = this.title;
        data["placeholder"] = this.placeholder;
        data["lengthLimit"] = this.lengthLimit;
        data["maxLines"] = this.maxLines;
        data["minLines"] = this.minLines;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICustomFields {
    id?: number;
    isRequired?: boolean;
    sequence?: number;
    inputType?: string;
    title?: string;
    placeholder?: string;
    lengthLimit?: number;
    maxLines?: number;
    minLines?: number;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CollectionPointPageDetail implements ICollectionPointPageDetail {
    themeId!: number;
    acceptCheckBoxText!: string;
    backgroundImageId?: number;
    bodyBottomDescriptionText!: string;
    bodyTopDescriptionText!: string;
    cancelButtonText!: string;
    confirmButtonText!: string;
    headerBackgroundImageId?: number;
    headerText!: string;
    logoImageId?: number;
    policyUrlText!: string;
    policyUrl?: string;
    redirectUrl?: string;
    successHeaderText!: string;
    successDescriptionText?: string;
    successButtonText!: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointPageDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.themeId = _data["themeId"];
            this.acceptCheckBoxText = _data["acceptCheckBoxText"];
            this.backgroundImageId = _data["backgroundImageId"];
            this.bodyBottomDescriptionText = _data["bodyBottomDescriptionText"];
            this.bodyTopDescriptionText = _data["bodyTopDescriptionText"];
            this.cancelButtonText = _data["cancelButtonText"];
            this.confirmButtonText = _data["confirmButtonText"];
            this.headerBackgroundImageId = _data["headerBackgroundImageId"];
            this.headerText = _data["headerText"];
            this.logoImageId = _data["logoImageId"];
            this.policyUrlText = _data["policyUrlText"];
            this.policyUrl = _data["policyUrl"];
            this.redirectUrl = _data["redirectUrl"];
            this.successHeaderText = _data["successHeaderText"];
            this.successDescriptionText = _data["successDescriptionText"];
            this.successButtonText = _data["successButtonText"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointPageDetail {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointPageDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["themeId"] = this.themeId;
        data["acceptCheckBoxText"] = this.acceptCheckBoxText;
        data["backgroundImageId"] = this.backgroundImageId;
        data["bodyBottomDescriptionText"] = this.bodyBottomDescriptionText;
        data["bodyTopDescriptionText"] = this.bodyTopDescriptionText;
        data["cancelButtonText"] = this.cancelButtonText;
        data["confirmButtonText"] = this.confirmButtonText;
        data["headerBackgroundImageId"] = this.headerBackgroundImageId;
        data["headerText"] = this.headerText;
        data["logoImageId"] = this.logoImageId;
        data["policyUrlText"] = this.policyUrlText;
        data["policyUrl"] = this.policyUrl;
        data["redirectUrl"] = this.redirectUrl;
        data["successHeaderText"] = this.successHeaderText;
        data["successDescriptionText"] = this.successDescriptionText;
        data["successButtonText"] = this.successButtonText;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointPageDetail {
    themeId: number;
    acceptCheckBoxText: string;
    backgroundImageId?: number;
    bodyBottomDescriptionText: string;
    bodyTopDescriptionText: string;
    cancelButtonText: string;
    confirmButtonText: string;
    headerBackgroundImageId?: number;
    headerText: string;
    logoImageId?: number;
    policyUrlText: string;
    policyUrl?: string;
    redirectUrl?: string;
    successHeaderText: string;
    successDescriptionText?: string;
    successButtonText: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CreateCollectionPointCommand implements ICreateCollectionPointCommand {
    code?: string;
    consentKeyIdentifier?: CollectionPointConsentKeyIdentifier[];
    customFieldsList?: CollectionPointCustomFields[];
    expirationPeriod?: string;
    language?: string;
    pageDetail?: CollectionPointPageDetail;
    purposesList?: CollectionPointPurpose[];
    websiteId?: number;

    constructor(data?: ICreateCollectionPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            if (Array.isArray(_data["consentKeyIdentifier"])) {
                this.consentKeyIdentifier = [] as any;
                for (let item of _data["consentKeyIdentifier"])
                    this.consentKeyIdentifier!.push(CollectionPointConsentKeyIdentifier.fromJS(item));
            }
            if (Array.isArray(_data["customFieldsList"])) {
                this.customFieldsList = [] as any;
                for (let item of _data["customFieldsList"])
                    this.customFieldsList!.push(CollectionPointCustomFields.fromJS(item));
            }
            this.expirationPeriod = _data["expirationPeriod"];
            this.language = _data["language"];
            this.pageDetail = _data["pageDetail"] ? CollectionPointPageDetail.fromJS(_data["pageDetail"]) : <any>undefined;
            if (Array.isArray(_data["purposesList"])) {
                this.purposesList = [] as any;
                for (let item of _data["purposesList"])
                    this.purposesList!.push(CollectionPointPurpose.fromJS(item));
            }
            this.websiteId = _data["websiteId"];
        }
    }

    static fromJS(data: any): CreateCollectionPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCollectionPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        if (Array.isArray(this.consentKeyIdentifier)) {
            data["consentKeyIdentifier"] = [];
            for (let item of this.consentKeyIdentifier)
                data["consentKeyIdentifier"].push(item.toJSON());
        }
        if (Array.isArray(this.customFieldsList)) {
            data["customFieldsList"] = [];
            for (let item of this.customFieldsList)
                data["customFieldsList"].push(item.toJSON());
        }
        data["expirationPeriod"] = this.expirationPeriod;
        data["language"] = this.language;
        data["pageDetail"] = this.pageDetail ? this.pageDetail.toJSON() : <any>undefined;
        if (Array.isArray(this.purposesList)) {
            data["purposesList"] = [];
            for (let item of this.purposesList)
                data["purposesList"].push(item.toJSON());
        }
        data["websiteId"] = this.websiteId;
        return data;
    }
}

export interface ICreateCollectionPointCommand {
    code?: string;
    consentKeyIdentifier?: CollectionPointConsentKeyIdentifier[];
    customFieldsList?: CollectionPointCustomFields[];
    expirationPeriod?: string;
    language?: string;
    pageDetail?: CollectionPointPageDetail;
    purposesList?: CollectionPointPurpose[];
    websiteId?: number;
}

export class CollectionPointConsentKeyIdentifier implements ICollectionPointConsentKeyIdentifier {
    code!: string;
    label?: string;
    isPrimaryKey!: boolean;
    isRequired!: boolean;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointConsentKeyIdentifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.label = _data["label"];
            this.isPrimaryKey = _data["isPrimaryKey"];
            this.isRequired = _data["isRequired"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointConsentKeyIdentifier {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointConsentKeyIdentifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["label"] = this.label;
        data["isPrimaryKey"] = this.isPrimaryKey;
        data["isRequired"] = this.isRequired;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointConsentKeyIdentifier {
    code: string;
    label?: string;
    isPrimaryKey: boolean;
    isRequired: boolean;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CollectionPointCustomFields implements ICollectionPointCustomFields {
    id!: number;
    isRequired!: boolean;
    sequence!: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointCustomFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isRequired = _data["isRequired"];
            this.sequence = _data["sequence"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointCustomFields {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointCustomFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isRequired"] = this.isRequired;
        data["sequence"] = this.sequence;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointCustomFields {
    id: number;
    isRequired: boolean;
    sequence: number;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CollectionPointPurpose implements ICollectionPointPurpose {
    guid!: string;
    priority!: number;
    sectionId?: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointPurpose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.priority = _data["priority"];
            this.sectionId = _data["sectionId"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointPurpose {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointPurpose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["priority"] = this.priority;
        data["sectionId"] = this.sectionId;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointPurpose {
    guid: string;
    priority: number;
    sectionId?: number;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class UpdateCollectionPointCommand implements IUpdateCollectionPointCommand {
    id?: number;
    code?: string;
    consentKeyIdentifier?: CollectionPointConsentKeyIdentifier[];
    customFieldsList?: CollectionPointCustomFields[];
    expirationPeriod?: string;
    language?: string;
    pageDetail?: CollectionPointPageDetail;
    purposesList?: CollectionPointPurpose[];
    websiteId?: number;
    version?: number;

    constructor(data?: IUpdateCollectionPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            if (Array.isArray(_data["consentKeyIdentifier"])) {
                this.consentKeyIdentifier = [] as any;
                for (let item of _data["consentKeyIdentifier"])
                    this.consentKeyIdentifier!.push(CollectionPointConsentKeyIdentifier.fromJS(item));
            }
            if (Array.isArray(_data["customFieldsList"])) {
                this.customFieldsList = [] as any;
                for (let item of _data["customFieldsList"])
                    this.customFieldsList!.push(CollectionPointCustomFields.fromJS(item));
            }
            this.expirationPeriod = _data["expirationPeriod"];
            this.language = _data["language"];
            this.pageDetail = _data["pageDetail"] ? CollectionPointPageDetail.fromJS(_data["pageDetail"]) : <any>undefined;
            if (Array.isArray(_data["purposesList"])) {
                this.purposesList = [] as any;
                for (let item of _data["purposesList"])
                    this.purposesList!.push(CollectionPointPurpose.fromJS(item));
            }
            this.websiteId = _data["websiteId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateCollectionPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCollectionPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        if (Array.isArray(this.consentKeyIdentifier)) {
            data["consentKeyIdentifier"] = [];
            for (let item of this.consentKeyIdentifier)
                data["consentKeyIdentifier"].push(item.toJSON());
        }
        if (Array.isArray(this.customFieldsList)) {
            data["customFieldsList"] = [];
            for (let item of this.customFieldsList)
                data["customFieldsList"].push(item.toJSON());
        }
        data["expirationPeriod"] = this.expirationPeriod;
        data["language"] = this.language;
        data["pageDetail"] = this.pageDetail ? this.pageDetail.toJSON() : <any>undefined;
        if (Array.isArray(this.purposesList)) {
            data["purposesList"] = [];
            for (let item of this.purposesList)
                data["purposesList"].push(item.toJSON());
        }
        data["websiteId"] = this.websiteId;
        data["version"] = this.version;
        return data;
    }
}

export interface IUpdateCollectionPointCommand {
    id?: number;
    code?: string;
    consentKeyIdentifier?: CollectionPointConsentKeyIdentifier[];
    customFieldsList?: CollectionPointCustomFields[];
    expirationPeriod?: string;
    language?: string;
    pageDetail?: CollectionPointPageDetail;
    purposesList?: CollectionPointPurpose[];
    websiteId?: number;
    version?: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}