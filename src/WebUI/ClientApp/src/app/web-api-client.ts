//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.0.0 (NJsonSchema v10.7.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICustomFieldClient {
    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCollectionPointCustomFieldActiveList>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomFieldClient implements ICustomFieldClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCollectionPointCustomFieldActiveList> {
        let url_ = this.baseUrl + "/api/CustomField?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollectionPointsQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollectionPointsQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCollectionPointCustomFieldActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCollectionPointCustomFieldActiveList>;
        }));
    }

    protected processGetCollectionPointsQuery(response: HttpResponseBase): Observable<PaginatedListOfCollectionPointCustomFieldActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCollectionPointCustomFieldActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IGeneralConsentClient {
    getGeneralConsentQuery(paginationParams_Offset: number | null | undefined, paginationParams_Limit: number | null | undefined, sortingParams_SortName: string | null | undefined, sortingParams_SortDesc: number | null | undefined, generalConsentFilterKey_FullName: string | null | undefined, generalConsentFilterKey_PhoneNumber: string | null | undefined, generalConsentFilterKey_IdCardNumber: string | null | undefined, generalConsentFilterKey_Uid: number | null | undefined, generalConsentFilterKey_Email: string | null | undefined, generalConsentFilterKey_StartDate: Date | null | undefined, generalConsentFilterKey_EndDate: Date | null | undefined, currentUtcOffset: string | null | undefined, isCurrentlyDst: string | null | undefined): Observable<PaginatedListOfGeneralConsent>;
    create(command: SubmitConsentCommand): Observable<number>;
    getLatestId(query: GetLatestIdRequestQuery): Observable<number>;
    getGeneralConsentInfoQuery(query: GeneralConsentInfoRequestQuery): Observable<GeneralConsent>;
}

@Injectable({
    providedIn: 'root'
})
export class GeneralConsentClient implements IGeneralConsentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getGeneralConsentQuery(paginationParams_Offset: number | null | undefined, paginationParams_Limit: number | null | undefined, sortingParams_SortName: string | null | undefined, sortingParams_SortDesc: number | null | undefined, generalConsentFilterKey_FullName: string | null | undefined, generalConsentFilterKey_PhoneNumber: string | null | undefined, generalConsentFilterKey_IdCardNumber: string | null | undefined, generalConsentFilterKey_Uid: number | null | undefined, generalConsentFilterKey_Email: string | null | undefined, generalConsentFilterKey_StartDate: Date | null | undefined, generalConsentFilterKey_EndDate: Date | null | undefined, currentUtcOffset: string | null | undefined, isCurrentlyDst: string | null | undefined): Observable<PaginatedListOfGeneralConsent> {
        let url_ = this.baseUrl + "/api/GeneralConsent?";
        if (paginationParams_Offset !== undefined && paginationParams_Offset !== null)
            url_ += "PaginationParams.Offset=" + encodeURIComponent("" + paginationParams_Offset) + "&";
        if (paginationParams_Limit !== undefined && paginationParams_Limit !== null)
            url_ += "PaginationParams.Limit=" + encodeURIComponent("" + paginationParams_Limit) + "&";
        if (sortingParams_SortName !== undefined && sortingParams_SortName !== null)
            url_ += "SortingParams.SortName=" + encodeURIComponent("" + sortingParams_SortName) + "&";
        if (sortingParams_SortDesc !== undefined && sortingParams_SortDesc !== null)
            url_ += "SortingParams.SortDesc=" + encodeURIComponent("" + sortingParams_SortDesc) + "&";
        if (generalConsentFilterKey_FullName !== undefined && generalConsentFilterKey_FullName !== null)
            url_ += "GeneralConsentFilterKey.FullName=" + encodeURIComponent("" + generalConsentFilterKey_FullName) + "&";
        if (generalConsentFilterKey_PhoneNumber !== undefined && generalConsentFilterKey_PhoneNumber !== null)
            url_ += "GeneralConsentFilterKey.PhoneNumber=" + encodeURIComponent("" + generalConsentFilterKey_PhoneNumber) + "&";
        if (generalConsentFilterKey_IdCardNumber !== undefined && generalConsentFilterKey_IdCardNumber !== null)
            url_ += "GeneralConsentFilterKey.IdCardNumber=" + encodeURIComponent("" + generalConsentFilterKey_IdCardNumber) + "&";
        if (generalConsentFilterKey_Uid !== undefined && generalConsentFilterKey_Uid !== null)
            url_ += "GeneralConsentFilterKey.Uid=" + encodeURIComponent("" + generalConsentFilterKey_Uid) + "&";
        if (generalConsentFilterKey_Email !== undefined && generalConsentFilterKey_Email !== null)
            url_ += "GeneralConsentFilterKey.Email=" + encodeURIComponent("" + generalConsentFilterKey_Email) + "&";
        if (generalConsentFilterKey_StartDate !== undefined && generalConsentFilterKey_StartDate !== null)
            url_ += "GeneralConsentFilterKey.StartDate=" + encodeURIComponent(generalConsentFilterKey_StartDate ? "" + generalConsentFilterKey_StartDate.toISOString() : "") + "&";
        if (generalConsentFilterKey_EndDate !== undefined && generalConsentFilterKey_EndDate !== null)
            url_ += "GeneralConsentFilterKey.EndDate=" + encodeURIComponent(generalConsentFilterKey_EndDate ? "" + generalConsentFilterKey_EndDate.toISOString() : "") + "&";
        if (currentUtcOffset !== undefined && currentUtcOffset !== null)
            url_ += "CurrentUtcOffset=" + encodeURIComponent("" + currentUtcOffset) + "&";
        if (isCurrentlyDst !== undefined && isCurrentlyDst !== null)
            url_ += "IsCurrentlyDst=" + encodeURIComponent("" + isCurrentlyDst) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralConsentQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralConsentQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfGeneralConsent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfGeneralConsent>;
        }));
    }

    protected processGetGeneralConsentQuery(response: HttpResponseBase): Observable<PaginatedListOfGeneralConsent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfGeneralConsent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: SubmitConsentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/GeneralConsent/submit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLatestId(query: GetLatestIdRequestQuery): Observable<number> {
        let url_ = this.baseUrl + "/api/GeneralConsent/latest-id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLatestId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getGeneralConsentInfoQuery(query: GeneralConsentInfoRequestQuery): Observable<GeneralConsent> {
        let url_ = this.baseUrl + "/api/GeneralConsent/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralConsentInfoQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralConsentInfoQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralConsent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralConsent>;
        }));
    }

    protected processGetGeneralConsentInfoQuery(response: HttpResponseBase): Observable<GeneralConsent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralConsent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPurposeClient {
    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfPurposeActiveList>;
}

@Injectable({
    providedIn: 'root'
})
export class PurposeClient implements IPurposeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfPurposeActiveList> {
        let url_ = this.baseUrl + "/api/Purpose?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollectionPointsQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollectionPointsQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfPurposeActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfPurposeActiveList>;
        }));
    }

    protected processGetCollectionPointsQuery(response: HttpResponseBase): Observable<PaginatedListOfPurposeActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfPurposeActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISectionClient {
    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfSectionActiveList>;
}

@Injectable({
    providedIn: 'root'
})
export class SectionClient implements ISectionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfSectionActiveList> {
        let url_ = this.baseUrl + "/api/Section?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollectionPointsQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollectionPointsQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfSectionActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfSectionActiveList>;
        }));
    }

    protected processGetCollectionPointsQuery(response: HttpResponseBase): Observable<PaginatedListOfSectionActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfSectionActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWebsiteClient {
    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfWebsiteActiveList>;
}

@Injectable({
    providedIn: 'root'
})
export class WebsiteClient implements IWebsiteClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfWebsiteActiveList> {
        let url_ = this.baseUrl + "/api/Website?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollectionPointsQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollectionPointsQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfWebsiteActiveList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfWebsiteActiveList>;
        }));
    }

    protected processGetCollectionPointsQuery(response: HttpResponseBase): Observable<PaginatedListOfWebsiteActiveList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfWebsiteActiveList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICollectionPointsClient {
    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCollectionPointInfo>;
    create(command: CreateCollectionPointCommand): Observable<number>;
    update(id: number, command: UpdateCollectionPointCommand): Observable<FileResponse>;
    get(id: number): Observable<CollectionPointInfo>;
}

@Injectable({
    providedIn: 'root'
})
export class CollectionPointsClient implements ICollectionPointsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCollectionPointsQuery(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCollectionPointInfo> {
        let url_ = this.baseUrl + "/api/CollectionPoints?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCollectionPointsQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCollectionPointsQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCollectionPointInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCollectionPointInfo>;
        }));
    }

    protected processGetCollectionPointsQuery(response: HttpResponseBase): Observable<PaginatedListOfCollectionPointInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCollectionPointInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCollectionPointCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/CollectionPoints";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCollectionPointCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CollectionPoints/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(id: number): Observable<CollectionPointInfo> {
        let url_ = this.baseUrl + "/api/CollectionPoints/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CollectionPointInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CollectionPointInfo>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CollectionPointInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CollectionPointInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class PaginatedListOfCollectionPointCustomFieldActiveList implements IPaginatedListOfCollectionPointCustomFieldActiveList {
    items?: CollectionPointCustomFieldActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCollectionPointCustomFieldActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CollectionPointCustomFieldActiveList.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCollectionPointCustomFieldActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCollectionPointCustomFieldActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCollectionPointCustomFieldActiveList {
    items?: CollectionPointCustomFieldActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CollectionPointCustomFieldActiveList implements ICollectionPointCustomFieldActiveList {
    id?: number;
    code?: string;
    description?: string;
    type?: string;
    owner?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointCustomFieldActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.owner = _data["owner"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointCustomFieldActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointCustomFieldActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["description"] = this.description;
        data["type"] = this.type;
        data["owner"] = this.owner;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointCustomFieldActiveList {
    id?: number;
    code?: string;
    description?: string;
    type?: string;
    owner?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class PaginatedListOfGeneralConsent implements IPaginatedListOfGeneralConsent {
    items?: GeneralConsent[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfGeneralConsent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GeneralConsent.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfGeneralConsent {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfGeneralConsent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfGeneralConsent {
    items?: GeneralConsent[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GeneralConsent implements IGeneralConsent {
    consentId?: number;
    collectionPointId?: number;
    uid?: number;
    totalTransactions?: number;
    fullName?: string;
    collectionPointGuid?: string;
    consentDateTime?: Date;
    consentDateTimeDisplay?: string;
    websiteId?: number;
    collectionPointVersion?: number;
    websiteDescription?: string;
    purposeList?: GeneralConsentPurpose[];
    purpose?: string;
    fromBrowser?: string;
    fromWebsite?: string;
    phoneNumber?: string;
    idCardNumber?: string;
    email?: string;
    remark?: string;
    eventCode?: string;
    totalCount?: number;
    companyId?: number;
    companyName?: string;
    status?: string;
    createBy?: number;
    createByDisplay?: string;
    createDate?: Date;
    createDateDisplay?: string;
    updateBy?: number;
    updateByDisplay?: string;
    updateDate?: Date;
    updateDateDisplay?: string;
    verifyType?: string;
    row?: number;
    isStatus?: boolean;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IGeneralConsent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consentId = _data["consentId"];
            this.collectionPointId = _data["collectionPointId"];
            this.uid = _data["uid"];
            this.totalTransactions = _data["totalTransactions"];
            this.fullName = _data["fullName"];
            this.collectionPointGuid = _data["collectionPointGuid"];
            this.consentDateTime = _data["consentDateTime"] ? new Date(_data["consentDateTime"].toString()) : <any>undefined;
            this.consentDateTimeDisplay = _data["consentDateTimeDisplay"];
            this.websiteId = _data["websiteId"];
            this.collectionPointVersion = _data["collectionPointVersion"];
            this.websiteDescription = _data["websiteDescription"];
            if (Array.isArray(_data["purposeList"])) {
                this.purposeList = [] as any;
                for (let item of _data["purposeList"])
                    this.purposeList!.push(GeneralConsentPurpose.fromJS(item));
            }
            this.purpose = _data["purpose"];
            this.fromBrowser = _data["fromBrowser"];
            this.fromWebsite = _data["fromWebsite"];
            this.phoneNumber = _data["phoneNumber"];
            this.idCardNumber = _data["idCardNumber"];
            this.email = _data["email"];
            this.remark = _data["remark"];
            this.eventCode = _data["eventCode"];
            this.totalCount = _data["totalCount"];
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.status = _data["status"];
            this.createBy = _data["createBy"];
            this.createByDisplay = _data["createByDisplay"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.createDateDisplay = _data["createDateDisplay"];
            this.updateBy = _data["updateBy"];
            this.updateByDisplay = _data["updateByDisplay"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.updateDateDisplay = _data["updateDateDisplay"];
            this.verifyType = _data["verifyType"];
            this.row = _data["row"];
            this.isStatus = _data["isStatus"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): GeneralConsent {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralConsent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consentId"] = this.consentId;
        data["collectionPointId"] = this.collectionPointId;
        data["uid"] = this.uid;
        data["totalTransactions"] = this.totalTransactions;
        data["fullName"] = this.fullName;
        data["collectionPointGuid"] = this.collectionPointGuid;
        data["consentDateTime"] = this.consentDateTime ? this.consentDateTime.toISOString() : <any>undefined;
        data["consentDateTimeDisplay"] = this.consentDateTimeDisplay;
        data["websiteId"] = this.websiteId;
        data["collectionPointVersion"] = this.collectionPointVersion;
        data["websiteDescription"] = this.websiteDescription;
        if (Array.isArray(this.purposeList)) {
            data["purposeList"] = [];
            for (let item of this.purposeList)
                data["purposeList"].push(item.toJSON());
        }
        data["purpose"] = this.purpose;
        data["fromBrowser"] = this.fromBrowser;
        data["fromWebsite"] = this.fromWebsite;
        data["phoneNumber"] = this.phoneNumber;
        data["idCardNumber"] = this.idCardNumber;
        data["email"] = this.email;
        data["remark"] = this.remark;
        data["eventCode"] = this.eventCode;
        data["totalCount"] = this.totalCount;
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["status"] = this.status;
        data["createBy"] = this.createBy;
        data["createByDisplay"] = this.createByDisplay;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["createDateDisplay"] = this.createDateDisplay;
        data["updateBy"] = this.updateBy;
        data["updateByDisplay"] = this.updateByDisplay;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["updateDateDisplay"] = this.updateDateDisplay;
        data["verifyType"] = this.verifyType;
        data["row"] = this.row;
        data["isStatus"] = this.isStatus;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IGeneralConsent {
    consentId?: number;
    collectionPointId?: number;
    uid?: number;
    totalTransactions?: number;
    fullName?: string;
    collectionPointGuid?: string;
    consentDateTime?: Date;
    consentDateTimeDisplay?: string;
    websiteId?: number;
    collectionPointVersion?: number;
    websiteDescription?: string;
    purposeList?: GeneralConsentPurpose[];
    purpose?: string;
    fromBrowser?: string;
    fromWebsite?: string;
    phoneNumber?: string;
    idCardNumber?: string;
    email?: string;
    remark?: string;
    eventCode?: string;
    totalCount?: number;
    companyId?: number;
    companyName?: string;
    status?: string;
    createBy?: number;
    createByDisplay?: string;
    createDate?: Date;
    createDateDisplay?: string;
    updateBy?: number;
    updateByDisplay?: string;
    updateDate?: Date;
    updateDateDisplay?: string;
    verifyType?: string;
    row?: number;
    isStatus?: boolean;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class GeneralConsentPurpose implements IGeneralConsentPurpose {
    purposeId?: number;
    companyId?: number;
    purposeType?: string;
    code?: string;
    description?: string;
    warningDescription?: string;
    purposeCategoryId?: number;
    expiredDateTime?: string;
    guid?: string;
    version?: number;
    priority?: number;
    status?: string;
    createBy?: number;
    createDate?: Date;
    updateBy?: number;
    updateDate?: Date;
    active?: boolean;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IGeneralConsentPurpose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purposeId = _data["purposeId"];
            this.companyId = _data["companyId"];
            this.purposeType = _data["purposeType"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.warningDescription = _data["warningDescription"];
            this.purposeCategoryId = _data["purposeCategoryId"];
            this.expiredDateTime = _data["expiredDateTime"];
            this.guid = _data["guid"];
            this.version = _data["version"];
            this.priority = _data["priority"];
            this.status = _data["status"];
            this.createBy = _data["createBy"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.updateBy = _data["updateBy"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.active = _data["active"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): GeneralConsentPurpose {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralConsentPurpose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purposeId"] = this.purposeId;
        data["companyId"] = this.companyId;
        data["purposeType"] = this.purposeType;
        data["code"] = this.code;
        data["description"] = this.description;
        data["warningDescription"] = this.warningDescription;
        data["purposeCategoryId"] = this.purposeCategoryId;
        data["expiredDateTime"] = this.expiredDateTime;
        data["guid"] = this.guid;
        data["version"] = this.version;
        data["priority"] = this.priority;
        data["status"] = this.status;
        data["createBy"] = this.createBy;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["updateBy"] = this.updateBy;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["active"] = this.active;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IGeneralConsentPurpose {
    purposeId?: number;
    companyId?: number;
    purposeType?: string;
    code?: string;
    description?: string;
    warningDescription?: string;
    purposeCategoryId?: number;
    expiredDateTime?: string;
    guid?: string;
    version?: number;
    priority?: number;
    status?: string;
    createBy?: number;
    createDate?: Date;
    updateBy?: number;
    updateDate?: Date;
    active?: boolean;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class SubmitConsentCommand implements ISubmitConsentCommand {
    ageRangeCode?: string;
    collectionPointGuid?: string;
    companyId?: number;
    webSiteId?: number;
    uid?: number;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    fromBrowser?: string;
    fromWebsite?: string;
    verifyType?: string;
    eventCode?: string;
    idCardNumber?: string;
    expiredDateTime?: Date;
    consentSignature?: string;
    purpose?: SubmitConsentPurpose[];
    collectionPointCustomField?: SubmitCollectionPointCustomField[];

    constructor(data?: ISubmitConsentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ageRangeCode = _data["ageRangeCode"];
            this.collectionPointGuid = _data["collectionPointGuid"];
            this.companyId = _data["companyId"];
            this.webSiteId = _data["webSiteId"];
            this.uid = _data["uid"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.fromBrowser = _data["fromBrowser"];
            this.fromWebsite = _data["fromWebsite"];
            this.verifyType = _data["verifyType"];
            this.eventCode = _data["eventCode"];
            this.idCardNumber = _data["idCardNumber"];
            this.expiredDateTime = _data["expiredDateTime"] ? new Date(_data["expiredDateTime"].toString()) : <any>undefined;
            this.consentSignature = _data["consentSignature"];
            if (Array.isArray(_data["purpose"])) {
                this.purpose = [] as any;
                for (let item of _data["purpose"])
                    this.purpose!.push(SubmitConsentPurpose.fromJS(item));
            }
            if (Array.isArray(_data["collectionPointCustomField"])) {
                this.collectionPointCustomField = [] as any;
                for (let item of _data["collectionPointCustomField"])
                    this.collectionPointCustomField!.push(SubmitCollectionPointCustomField.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubmitConsentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitConsentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ageRangeCode"] = this.ageRangeCode;
        data["collectionPointGuid"] = this.collectionPointGuid;
        data["companyId"] = this.companyId;
        data["webSiteId"] = this.webSiteId;
        data["uid"] = this.uid;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["fromBrowser"] = this.fromBrowser;
        data["fromWebsite"] = this.fromWebsite;
        data["verifyType"] = this.verifyType;
        data["eventCode"] = this.eventCode;
        data["idCardNumber"] = this.idCardNumber;
        data["expiredDateTime"] = this.expiredDateTime ? this.expiredDateTime.toISOString() : <any>undefined;
        data["consentSignature"] = this.consentSignature;
        if (Array.isArray(this.purpose)) {
            data["purpose"] = [];
            for (let item of this.purpose)
                data["purpose"].push(item.toJSON());
        }
        if (Array.isArray(this.collectionPointCustomField)) {
            data["collectionPointCustomField"] = [];
            for (let item of this.collectionPointCustomField)
                data["collectionPointCustomField"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubmitConsentCommand {
    ageRangeCode?: string;
    collectionPointGuid?: string;
    companyId?: number;
    webSiteId?: number;
    uid?: number;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    fromBrowser?: string;
    fromWebsite?: string;
    verifyType?: string;
    eventCode?: string;
    idCardNumber?: string;
    expiredDateTime?: Date;
    consentSignature?: string;
    purpose?: SubmitConsentPurpose[];
    collectionPointCustomField?: SubmitCollectionPointCustomField[];
}

export class SubmitConsentPurpose implements ISubmitConsentPurpose {
    purposeGuid!: string;
    active?: boolean;
    expiredDateTime?: Date;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ISubmitConsentPurpose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purposeGuid = _data["purposeGuid"];
            this.active = _data["active"];
            this.expiredDateTime = _data["expiredDateTime"] ? new Date(_data["expiredDateTime"].toString()) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SubmitConsentPurpose {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitConsentPurpose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purposeGuid"] = this.purposeGuid;
        data["active"] = this.active;
        data["expiredDateTime"] = this.expiredDateTime ? this.expiredDateTime.toISOString() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ISubmitConsentPurpose {
    purposeGuid: string;
    active?: boolean;
    expiredDateTime?: Date;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class SubmitCollectionPointCustomField implements ISubmitCollectionPointCustomField {
    collectionPointCustomFieldConfigId?: number;
    value?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ISubmitCollectionPointCustomField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collectionPointCustomFieldConfigId = _data["collectionPointCustomFieldConfigId"];
            this.value = _data["value"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SubmitCollectionPointCustomField {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitCollectionPointCustomField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionPointCustomFieldConfigId"] = this.collectionPointCustomFieldConfigId;
        data["value"] = this.value;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ISubmitCollectionPointCustomField {
    collectionPointCustomFieldConfigId?: number;
    value?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class GetLatestIdRequestQuery implements IGetLatestIdRequestQuery {
    idCardNumber?: string;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    collectionPointGuid?: string;

    constructor(data?: IGetLatestIdRequestQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idCardNumber = _data["idCardNumber"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.collectionPointGuid = _data["collectionPointGuid"];
        }
    }

    static fromJS(data: any): GetLatestIdRequestQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestIdRequestQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idCardNumber"] = this.idCardNumber;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["collectionPointGuid"] = this.collectionPointGuid;
        return data;
    }
}

export interface IGetLatestIdRequestQuery {
    idCardNumber?: string;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    collectionPointGuid?: string;
}

export class GeneralConsentInfoRequestQuery implements IGeneralConsentInfoRequestQuery {
    idCardNumber?: string;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    collectionPointGuid?: string;

    constructor(data?: IGeneralConsentInfoRequestQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idCardNumber = _data["idCardNumber"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.collectionPointGuid = _data["collectionPointGuid"];
        }
    }

    static fromJS(data: any): GeneralConsentInfoRequestQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralConsentInfoRequestQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idCardNumber"] = this.idCardNumber;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["collectionPointGuid"] = this.collectionPointGuid;
        return data;
    }
}

export interface IGeneralConsentInfoRequestQuery {
    idCardNumber?: string;
    fullName?: string;
    email?: string;
    phoneNumber?: string;
    collectionPointGuid?: string;
}

export class PaginatedListOfPurposeActiveList implements IPaginatedListOfPurposeActiveList {
    items?: PurposeActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfPurposeActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PurposeActiveList.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfPurposeActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPurposeActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfPurposeActiveList {
    items?: PurposeActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PurposeActiveList implements IPurposeActiveList {
    purposeId?: number;
    code?: string;
    description?: string;
    expiredDateTime?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IPurposeActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purposeId = _data["purposeId"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.expiredDateTime = _data["expiredDateTime"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PurposeActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PurposeActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purposeId"] = this.purposeId;
        data["code"] = this.code;
        data["description"] = this.description;
        data["expiredDateTime"] = this.expiredDateTime;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IPurposeActiveList {
    purposeId?: number;
    code?: string;
    description?: string;
    expiredDateTime?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class PaginatedListOfSectionActiveList implements IPaginatedListOfSectionActiveList {
    items?: SectionActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfSectionActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SectionActiveList.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfSectionActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSectionActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfSectionActiveList {
    items?: SectionActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SectionActiveList implements ISectionActiveList {
    sectionId?: number;
    code?: string;
    description?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ISectionActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sectionId = _data["sectionId"];
            this.code = _data["code"];
            this.description = _data["description"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): SectionActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new SectionActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sectionId"] = this.sectionId;
        data["code"] = this.code;
        data["description"] = this.description;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ISectionActiveList {
    sectionId?: number;
    code?: string;
    description?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class PaginatedListOfWebsiteActiveList implements IPaginatedListOfWebsiteActiveList {
    items?: WebsiteActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfWebsiteActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WebsiteActiveList.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfWebsiteActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfWebsiteActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfWebsiteActiveList {
    items?: WebsiteActiveList[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WebsiteActiveList implements IWebsiteActiveList {
    websiteId?: number;
    code?: string;
    description?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IWebsiteActiveList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.websiteId = _data["websiteId"];
            this.code = _data["code"];
            this.description = _data["description"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): WebsiteActiveList {
        data = typeof data === 'object' ? data : {};
        let result = new WebsiteActiveList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["websiteId"] = this.websiteId;
        data["code"] = this.code;
        data["description"] = this.description;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IWebsiteActiveList {
    websiteId?: number;
    code?: string;
    description?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class PaginatedListOfCollectionPointInfo implements IPaginatedListOfCollectionPointInfo {
    items?: CollectionPointInfo[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCollectionPointInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CollectionPointInfo.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCollectionPointInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCollectionPointInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCollectionPointInfo {
    items?: CollectionPointInfo[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CollectionPointInfo implements ICollectionPointInfo {
    collectionPointId?: number;
    collectionPoint?: string;
    websiteId?: number;
    accessToken?: string;
    guid?: string;
    websiteDescription?: string;
    websiteUrl?: string;
    websitePolicy?: string;
    description?: string;
    script?: string;
    purposeList?: GeneralConsentPurpose[];
    customFieldsList?: CollectionPointCustomFields[];
    expiredDateTime?: string;
    companyId?: number;
    version?: number;
    status?: string;
    statusDisplay?: string;
    createBy?: number;
    createByDisplay?: string;
    createDate?: Date;
    createDateDisplay?: string;
    updateBy?: number;
    updateByDisplay?: string;
    updateDate?: Date;
    updateDateDisplay?: string;
    row?: number;
    isStatus?: boolean;
    pageDetail?: CollectionPointPageDetail;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collectionPointId = _data["collectionPointId"];
            this.collectionPoint = _data["collectionPoint"];
            this.websiteId = _data["websiteId"];
            this.accessToken = _data["accessToken"];
            this.guid = _data["guid"];
            this.websiteDescription = _data["websiteDescription"];
            this.websiteUrl = _data["websiteUrl"];
            this.websitePolicy = _data["websitePolicy"];
            this.description = _data["description"];
            this.script = _data["script"];
            if (Array.isArray(_data["purposeList"])) {
                this.purposeList = [] as any;
                for (let item of _data["purposeList"])
                    this.purposeList!.push(GeneralConsentPurpose.fromJS(item));
            }
            if (Array.isArray(_data["customFieldsList"])) {
                this.customFieldsList = [] as any;
                for (let item of _data["customFieldsList"])
                    this.customFieldsList!.push(CollectionPointCustomFields.fromJS(item));
            }
            this.expiredDateTime = _data["expiredDateTime"];
            this.companyId = _data["companyId"];
            this.version = _data["version"];
            this.status = _data["status"];
            this.statusDisplay = _data["statusDisplay"];
            this.createBy = _data["createBy"];
            this.createByDisplay = _data["createByDisplay"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.createDateDisplay = _data["createDateDisplay"];
            this.updateBy = _data["updateBy"];
            this.updateByDisplay = _data["updateByDisplay"];
            this.updateDate = _data["updateDate"] ? new Date(_data["updateDate"].toString()) : <any>undefined;
            this.updateDateDisplay = _data["updateDateDisplay"];
            this.row = _data["row"];
            this.isStatus = _data["isStatus"];
            this.pageDetail = _data["pageDetail"] ? CollectionPointPageDetail.fromJS(_data["pageDetail"]) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionPointId"] = this.collectionPointId;
        data["collectionPoint"] = this.collectionPoint;
        data["websiteId"] = this.websiteId;
        data["accessToken"] = this.accessToken;
        data["guid"] = this.guid;
        data["websiteDescription"] = this.websiteDescription;
        data["websiteUrl"] = this.websiteUrl;
        data["websitePolicy"] = this.websitePolicy;
        data["description"] = this.description;
        data["script"] = this.script;
        if (Array.isArray(this.purposeList)) {
            data["purposeList"] = [];
            for (let item of this.purposeList)
                data["purposeList"].push(item.toJSON());
        }
        if (Array.isArray(this.customFieldsList)) {
            data["customFieldsList"] = [];
            for (let item of this.customFieldsList)
                data["customFieldsList"].push(item.toJSON());
        }
        data["expiredDateTime"] = this.expiredDateTime;
        data["companyId"] = this.companyId;
        data["version"] = this.version;
        data["status"] = this.status;
        data["statusDisplay"] = this.statusDisplay;
        data["createBy"] = this.createBy;
        data["createByDisplay"] = this.createByDisplay;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["createDateDisplay"] = this.createDateDisplay;
        data["updateBy"] = this.updateBy;
        data["updateByDisplay"] = this.updateByDisplay;
        data["updateDate"] = this.updateDate ? this.updateDate.toISOString() : <any>undefined;
        data["updateDateDisplay"] = this.updateDateDisplay;
        data["row"] = this.row;
        data["isStatus"] = this.isStatus;
        data["pageDetail"] = this.pageDetail ? this.pageDetail.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointInfo {
    collectionPointId?: number;
    collectionPoint?: string;
    websiteId?: number;
    accessToken?: string;
    guid?: string;
    websiteDescription?: string;
    websiteUrl?: string;
    websitePolicy?: string;
    description?: string;
    script?: string;
    purposeList?: GeneralConsentPurpose[];
    customFieldsList?: CollectionPointCustomFields[];
    expiredDateTime?: string;
    companyId?: number;
    version?: number;
    status?: string;
    statusDisplay?: string;
    createBy?: number;
    createByDisplay?: string;
    createDate?: Date;
    createDateDisplay?: string;
    updateBy?: number;
    updateByDisplay?: string;
    updateDate?: Date;
    updateDateDisplay?: string;
    row?: number;
    isStatus?: boolean;
    pageDetail?: CollectionPointPageDetail;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CollectionPointCustomFields implements ICollectionPointCustomFields {
    id!: number;
    isRequired!: boolean;
    sequence!: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointCustomFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isRequired = _data["isRequired"];
            this.sequence = _data["sequence"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointCustomFields {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointCustomFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isRequired"] = this.isRequired;
        data["sequence"] = this.sequence;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointCustomFields {
    id: number;
    isRequired: boolean;
    sequence: number;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CollectionPointPageDetail implements ICollectionPointPageDetail {
    acceptCheckBoxLabel?: string;
    acceptCheckBoxLabelFontColor?: string;
    bodyBackgroundColor?: string;
    bodyBackgroundId?: number;
    bodyBackground?: string;
    bodyBottomDescription?: string;
    bodyBottomDescriptionFontColor?: string;
    bodyTopDescription?: string;
    bodyTopDerscriptionFontColor?: string;
    cancelButtonBackgroundColor?: string;
    cancelButtonFontColor?: string;
    cancelButtonLabel?: string;
    confirmButtonLabel?: string;
    headerBackgroundColor?: string;
    headerBackgroundId?: number;
    headerBackground?: string;
    headerFontColor?: string;
    headerLabel?: string;
    logo?: string;
    logoId?: number;
    okButtonBackgroundColor?: string;
    okButtonFontColor?: string;
    policyUrl?: string;
    policyUrlLabel?: string;
    purposeAcceptLabel?: string;
    policyUrlLabelFontColor?: string;
    purposeRejectLabel?: string;
    redirectUrl?: string;
    successHeaderLabel?: string;
    successDescription?: string;
    successButtonLabel?: string;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointPageDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.acceptCheckBoxLabel = _data["acceptCheckBoxLabel"];
            this.acceptCheckBoxLabelFontColor = _data["acceptCheckBoxLabelFontColor"];
            this.bodyBackgroundColor = _data["bodyBackgroundColor"];
            this.bodyBackgroundId = _data["bodyBackgroundId"];
            this.bodyBackground = _data["bodyBackground"];
            this.bodyBottomDescription = _data["bodyBottomDescription"];
            this.bodyBottomDescriptionFontColor = _data["bodyBottomDescriptionFontColor"];
            this.bodyTopDescription = _data["bodyTopDescription"];
            this.bodyTopDerscriptionFontColor = _data["bodyTopDerscriptionFontColor"];
            this.cancelButtonBackgroundColor = _data["cancelButtonBackgroundColor"];
            this.cancelButtonFontColor = _data["cancelButtonFontColor"];
            this.cancelButtonLabel = _data["cancelButtonLabel"];
            this.confirmButtonLabel = _data["confirmButtonLabel"];
            this.headerBackgroundColor = _data["headerBackgroundColor"];
            this.headerBackgroundId = _data["headerBackgroundId"];
            this.headerBackground = _data["headerBackground"];
            this.headerFontColor = _data["headerFontColor"];
            this.headerLabel = _data["headerLabel"];
            this.logo = _data["logo"];
            this.logoId = _data["logoId"];
            this.okButtonBackgroundColor = _data["okButtonBackgroundColor"];
            this.okButtonFontColor = _data["okButtonFontColor"];
            this.policyUrl = _data["policyUrl"];
            this.policyUrlLabel = _data["policyUrlLabel"];
            this.purposeAcceptLabel = _data["purposeAcceptLabel"];
            this.policyUrlLabelFontColor = _data["policyUrlLabelFontColor"];
            this.purposeRejectLabel = _data["purposeRejectLabel"];
            this.redirectUrl = _data["redirectUrl"];
            this.successHeaderLabel = _data["successHeaderLabel"];
            this.successDescription = _data["successDescription"];
            this.successButtonLabel = _data["successButtonLabel"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointPageDetail {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointPageDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acceptCheckBoxLabel"] = this.acceptCheckBoxLabel;
        data["acceptCheckBoxLabelFontColor"] = this.acceptCheckBoxLabelFontColor;
        data["bodyBackgroundColor"] = this.bodyBackgroundColor;
        data["bodyBackgroundId"] = this.bodyBackgroundId;
        data["bodyBackground"] = this.bodyBackground;
        data["bodyBottomDescription"] = this.bodyBottomDescription;
        data["bodyBottomDescriptionFontColor"] = this.bodyBottomDescriptionFontColor;
        data["bodyTopDescription"] = this.bodyTopDescription;
        data["bodyTopDerscriptionFontColor"] = this.bodyTopDerscriptionFontColor;
        data["cancelButtonBackgroundColor"] = this.cancelButtonBackgroundColor;
        data["cancelButtonFontColor"] = this.cancelButtonFontColor;
        data["cancelButtonLabel"] = this.cancelButtonLabel;
        data["confirmButtonLabel"] = this.confirmButtonLabel;
        data["headerBackgroundColor"] = this.headerBackgroundColor;
        data["headerBackgroundId"] = this.headerBackgroundId;
        data["headerBackground"] = this.headerBackground;
        data["headerFontColor"] = this.headerFontColor;
        data["headerLabel"] = this.headerLabel;
        data["logo"] = this.logo;
        data["logoId"] = this.logoId;
        data["okButtonBackgroundColor"] = this.okButtonBackgroundColor;
        data["okButtonFontColor"] = this.okButtonFontColor;
        data["policyUrl"] = this.policyUrl;
        data["policyUrlLabel"] = this.policyUrlLabel;
        data["purposeAcceptLabel"] = this.purposeAcceptLabel;
        data["policyUrlLabelFontColor"] = this.policyUrlLabelFontColor;
        data["purposeRejectLabel"] = this.purposeRejectLabel;
        data["redirectUrl"] = this.redirectUrl;
        data["successHeaderLabel"] = this.successHeaderLabel;
        data["successDescription"] = this.successDescription;
        data["successButtonLabel"] = this.successButtonLabel;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointPageDetail {
    acceptCheckBoxLabel?: string;
    acceptCheckBoxLabelFontColor?: string;
    bodyBackgroundColor?: string;
    bodyBackgroundId?: number;
    bodyBackground?: string;
    bodyBottomDescription?: string;
    bodyBottomDescriptionFontColor?: string;
    bodyTopDescription?: string;
    bodyTopDerscriptionFontColor?: string;
    cancelButtonBackgroundColor?: string;
    cancelButtonFontColor?: string;
    cancelButtonLabel?: string;
    confirmButtonLabel?: string;
    headerBackgroundColor?: string;
    headerBackgroundId?: number;
    headerBackground?: string;
    headerFontColor?: string;
    headerLabel?: string;
    logo?: string;
    logoId?: number;
    okButtonBackgroundColor?: string;
    okButtonFontColor?: string;
    policyUrl?: string;
    policyUrlLabel?: string;
    purposeAcceptLabel?: string;
    policyUrlLabelFontColor?: string;
    purposeRejectLabel?: string;
    redirectUrl?: string;
    successHeaderLabel?: string;
    successDescription?: string;
    successButtonLabel?: string;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CreateCollectionPointCommand implements ICreateCollectionPointCommand {
    code?: string;
    consentKeyIdentifier?: CollectionPointConsentKeyIdentifier[];
    customFieldsList?: CollectionPointCustomFields[];
    expirationPeriod?: string;
    language?: string;
    pageDetail?: CollectionPointPageDetail;
    purposesList?: CollectionPointPurpose[];
    websiteId?: number;

    constructor(data?: ICreateCollectionPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            if (Array.isArray(_data["consentKeyIdentifier"])) {
                this.consentKeyIdentifier = [] as any;
                for (let item of _data["consentKeyIdentifier"])
                    this.consentKeyIdentifier!.push(CollectionPointConsentKeyIdentifier.fromJS(item));
            }
            if (Array.isArray(_data["customFieldsList"])) {
                this.customFieldsList = [] as any;
                for (let item of _data["customFieldsList"])
                    this.customFieldsList!.push(CollectionPointCustomFields.fromJS(item));
            }
            this.expirationPeriod = _data["expirationPeriod"];
            this.language = _data["language"];
            this.pageDetail = _data["pageDetail"] ? CollectionPointPageDetail.fromJS(_data["pageDetail"]) : <any>undefined;
            if (Array.isArray(_data["purposesList"])) {
                this.purposesList = [] as any;
                for (let item of _data["purposesList"])
                    this.purposesList!.push(CollectionPointPurpose.fromJS(item));
            }
            this.websiteId = _data["websiteId"];
        }
    }

    static fromJS(data: any): CreateCollectionPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCollectionPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        if (Array.isArray(this.consentKeyIdentifier)) {
            data["consentKeyIdentifier"] = [];
            for (let item of this.consentKeyIdentifier)
                data["consentKeyIdentifier"].push(item.toJSON());
        }
        if (Array.isArray(this.customFieldsList)) {
            data["customFieldsList"] = [];
            for (let item of this.customFieldsList)
                data["customFieldsList"].push(item.toJSON());
        }
        data["expirationPeriod"] = this.expirationPeriod;
        data["language"] = this.language;
        data["pageDetail"] = this.pageDetail ? this.pageDetail.toJSON() : <any>undefined;
        if (Array.isArray(this.purposesList)) {
            data["purposesList"] = [];
            for (let item of this.purposesList)
                data["purposesList"].push(item.toJSON());
        }
        data["websiteId"] = this.websiteId;
        return data;
    }
}

export interface ICreateCollectionPointCommand {
    code?: string;
    consentKeyIdentifier?: CollectionPointConsentKeyIdentifier[];
    customFieldsList?: CollectionPointCustomFields[];
    expirationPeriod?: string;
    language?: string;
    pageDetail?: CollectionPointPageDetail;
    purposesList?: CollectionPointPurpose[];
    websiteId?: number;
}

export class CollectionPointConsentKeyIdentifier implements ICollectionPointConsentKeyIdentifier {
    code!: string;
    label?: string;
    isPrimaryKey!: boolean;
    isRequired!: boolean;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointConsentKeyIdentifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.label = _data["label"];
            this.isPrimaryKey = _data["isPrimaryKey"];
            this.isRequired = _data["isRequired"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointConsentKeyIdentifier {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointConsentKeyIdentifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["label"] = this.label;
        data["isPrimaryKey"] = this.isPrimaryKey;
        data["isRequired"] = this.isRequired;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointConsentKeyIdentifier {
    code: string;
    label?: string;
    isPrimaryKey: boolean;
    isRequired: boolean;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CollectionPointPurpose implements ICollectionPointPurpose {
    guid!: string;
    priority!: number;
    sectionId?: number;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICollectionPointPurpose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.priority = _data["priority"];
            this.sectionId = _data["sectionId"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CollectionPointPurpose {
        data = typeof data === 'object' ? data : {};
        let result = new CollectionPointPurpose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["priority"] = this.priority;
        data["sectionId"] = this.sectionId;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICollectionPointPurpose {
    guid: string;
    priority: number;
    sectionId?: number;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class UpdateCollectionPointCommand implements IUpdateCollectionPointCommand {
    id?: number;
    code?: string;
    consentKeyIdentifier?: CollectionPointConsentKeyIdentifier[];
    customFieldsList?: CollectionPointCustomFields[];
    expirationPeriod?: string;
    language?: string;
    pageDetail?: CollectionPointPageDetail;
    purposesList?: CollectionPointPurpose[];
    websiteId?: number;
    version?: number;

    constructor(data?: IUpdateCollectionPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            if (Array.isArray(_data["consentKeyIdentifier"])) {
                this.consentKeyIdentifier = [] as any;
                for (let item of _data["consentKeyIdentifier"])
                    this.consentKeyIdentifier!.push(CollectionPointConsentKeyIdentifier.fromJS(item));
            }
            if (Array.isArray(_data["customFieldsList"])) {
                this.customFieldsList = [] as any;
                for (let item of _data["customFieldsList"])
                    this.customFieldsList!.push(CollectionPointCustomFields.fromJS(item));
            }
            this.expirationPeriod = _data["expirationPeriod"];
            this.language = _data["language"];
            this.pageDetail = _data["pageDetail"] ? CollectionPointPageDetail.fromJS(_data["pageDetail"]) : <any>undefined;
            if (Array.isArray(_data["purposesList"])) {
                this.purposesList = [] as any;
                for (let item of _data["purposesList"])
                    this.purposesList!.push(CollectionPointPurpose.fromJS(item));
            }
            this.websiteId = _data["websiteId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): UpdateCollectionPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCollectionPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        if (Array.isArray(this.consentKeyIdentifier)) {
            data["consentKeyIdentifier"] = [];
            for (let item of this.consentKeyIdentifier)
                data["consentKeyIdentifier"].push(item.toJSON());
        }
        if (Array.isArray(this.customFieldsList)) {
            data["customFieldsList"] = [];
            for (let item of this.customFieldsList)
                data["customFieldsList"].push(item.toJSON());
        }
        data["expirationPeriod"] = this.expirationPeriod;
        data["language"] = this.language;
        data["pageDetail"] = this.pageDetail ? this.pageDetail.toJSON() : <any>undefined;
        if (Array.isArray(this.purposesList)) {
            data["purposesList"] = [];
            for (let item of this.purposesList)
                data["purposesList"].push(item.toJSON());
        }
        data["websiteId"] = this.websiteId;
        data["version"] = this.version;
        return data;
    }
}

export interface IUpdateCollectionPointCommand {
    id?: number;
    code?: string;
    consentKeyIdentifier?: CollectionPointConsentKeyIdentifier[];
    customFieldsList?: CollectionPointCustomFields[];
    expirationPeriod?: string;
    language?: string;
    pageDetail?: CollectionPointPageDetail;
    purposesList?: CollectionPointPurpose[];
    websiteId?: number;
    version?: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}